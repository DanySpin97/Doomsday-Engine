// Handling the lobby session, for all master, server and client.
// Master servers are only for the TCP/IP protocol (i.e. Internet).

#include "jtNet.h"
#include "jtNetEx.h"

#include <stdio.h>
#include <process.h>
#include <dprintf.h>

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// MACROS -----------------------------------------------------------------

// Server lobby info flags.
#define SLIF_LOCKED		0x1			// The server isn't accepting players.

// Master requests.
#define MRQ_SERVERS		0xabcd0001	// List of servers.

// TYPES ------------------------------------------------------------------

// Information about a server.
struct serverLobbyInfo_t
{
	char	name[64];
	char	description[128];
	int		players, maxPlayers;
	int		canJoin;
	int		data[3];
};

struct groupenum_t
{
	DPID	id;
	DPNAME	*name;
	bool	found;
};

// Goes alongside the server list.
struct serverAddress_t
{
	void	*dPlayAddress;
	DWORD	dpaSize;
};

// FUNCTIONS --------------------------------------------------------------

void ClearServerList(void);

// DATA -------------------------------------------------------------------

bool			inited = false;

// The DPlay object that the master and the clients use to communicate
// with each other.
LPDIRECTPLAY4A	dPMaster = NULL;	

// The master session. Opened on the master computer, joined to by servers 
// and clients.
DPSESSIONDESC2	sdMaster;

// Lobby player ID. Masters have serverplayer id.
DPID			lobbyId;

// The address of the master.
char			masterAddress[128] = "0.0.0.0";
int				masterPort;

// This list will be generated by the master's server enumerator.
jtnetserver_t	*serverList = NULL;
serverAddress_t	*serverAddrs = NULL;
int				numServers = 0;

// Will be set to true when a client or a server is connected to the
// master server.
int				masterConnection = JTNET_ERROR_UNAVAILABLE;

// Will be set to true when a client receives the list of servers.
// The application can monitor this variable to know when the list
// has been received.
int				listReceived = true;

// CODE -------------------------------------------------------------------

int CreateMasterAddress(void **mAddr)
{
	DPCOMPOUNDADDRESSELEMENT elem[3];
	void		*addr;
	DWORD		size;
	int			count = 0;

	// service provider
	elem[count].guidDataType = DPAID_ServiceProvider;
	elem[count].dwDataSize = sizeof(GUID);
	elem[count].lpData = (LPVOID) &DPSPGUID_TCPIP;
	count++;

	// IP address string
	elem[count].guidDataType = DPAID_INet;
	elem[count].dwDataSize = lstrlen(masterAddress) + 1;
	elem[count].lpData = masterAddress;
	count++;

	// Optional Port number
	if(masterPort > 0)
	{
		elem[count].guidDataType = DPAID_INetPort;
		elem[count].dwDataSize = sizeof(WORD);
		elem[count].lpData = &masterPort;
		count++;
	}

	// How much room is needed?
	dPLobby->CreateCompoundAddress(elem, count, NULL, &size);
	addr = malloc(size);
	if(FAILED(dPLobby->CreateCompoundAddress(elem, count, addr, &size)))
	{
		free(addr);
		return JTNET_ERROR_GENERIC;
	}
	
	// Return the info.
	*mAddr = addr;

	return JTNET_OK;
}

// Initializes TCP/IP for dPMaster.
int jtInitMaster(void)
{
	void	*addr;

	if(inited && dPMaster) return JTNET_OK;

	if(FAILED(CoCreateInstance(CLSID_DirectPlay, NULL,
		CLSCTX_INPROC_SERVER, IID_IDirectPlay4A, (void**) &dPMaster)))
		return JTNET_ERROR_GENERIC;

	if(FAILED(CreateMasterAddress(&addr)))
		return JTNET_ERROR_GENERIC;

	if(FAILED(dPMaster->InitializeConnection(addr, 0)))
	{
		free(addr);
		return JTNET_ERROR_INIT_SERVICES;
	}
		
	free(addr);
	inited = true;
	masterConnection = JTNET_ERROR_UNAVAILABLE;
	return JTNET_OK;
}

// Releases the dPMaster object.
void jtNetCloseMaster(void)
{
	if(!inited) return;
	inited = false;

	ClearServerList();

	if(dPMaster) dPMaster->Release();
	dPMaster = NULL;
}

// Creates the master session and the master player.
// Servers and clients can connect after this.
int jtNetOpenMaster(void)
{
	DPSESSIONDESC2	*sd;
	HRESULT			hr;
	DPNAME			dpName;

	// Make sure dPMaster is initialized.
	if(jtInitMaster() != JTNET_OK) 
		return JTNET_ERROR_INIT_SERVICES;

	sd = &sdMaster;
	memset(sd, 0, sizeof(*sd));
	sd->dwSize = sizeof(*sd);
	sd->dwFlags = DPSESSION_CLIENTSERVER | DPSESSION_DIRECTPLAYPROTOCOL
		| DPSESSION_KEEPALIVE;
	sd->guidApplication = GUID_jtNetMaster;
	
	// Open the session.
	while((hr=dPMaster->Open(sd, DPOPEN_CREATE | DPOPEN_RETURNSTATUS)) 
		== DPERR_CONNECTING);
	if(hr != DP_OK) return JTNET_ERROR_OPEN_MASTER;

	// Create the master player.
	memset(&dpName, 0, sizeof(dpName));
	dpName.dwSize = sizeof(dpName);
	dpName.lpszShortNameA = dpName.lpszLongNameA = "Lobby Master";
	if(FAILED(dPMaster->CreatePlayer(&lobbyId, &dpName, NULL, NULL, 0, 
		DPPLAYER_SERVERPLAYER)))
	{
		return JTNET_ERROR_CREATE_PLAYER;
	}
	return JTNET_OK;
}

void PrepareSLInfo(serverLobbyInfo_t *sli)
{
	void *buffer = NULL;
	DWORD bsize = 0;
	DPSESSIONDESC2 *sd;
	
	dPlay->GetSessionDesc(NULL, &bsize);
	buffer = malloc(bsize);
	dPlay->GetSessionDesc(buffer, &bsize);

	sd = (DPSESSIONDESC2*) buffer;
	
	// The local player is a server.
	// Include server info.
	memset(sli, 0, sizeof(*sli));
	strcpy(sli->name, serverNameStr);
	strcpy(sli->description, serverInfoStr);
	sli->players = sd->dwCurrentPlayers;
	sli->maxPlayers = sd->dwMaxPlayers;
	sli->canJoin = !(sd->dwFlags & DPSESSION_JOINDISABLED);
	sli->data[0] = sd->dwUser2;
	sli->data[1] = sd->dwUser3;
	sli->data[2] = sd->dwUser4;

	free(buffer);
}

BOOL FAR PASCAL Cb_ConnectToMaster(const DPSESSIONDESC2 *lpThisSD, 
	DWORD *lpdwTimeOut, DWORD dwFlags, VOID *lpContext)
{
	HRESULT hr;
	DPNAME name;
	serverLobbyInfo_t sli;
	bool includeData = false;
	bool *success = (bool*) lpContext;

	// Open the session.
	while((hr = dPMaster->Open( (DPSESSIONDESC2*) lpThisSD, 
		DPOPEN_JOIN | DPOPEN_RETURNSTATUS)) == DPERR_CONNECTING) Sleep(5);
	if(hr != DP_OK) return FALSE;

	memcpy(&sdMaster, lpThisSD, sizeof(sdMaster));

	// The application name is the name of the player.
	memset(&name, 0, sizeof(name));
	name.dwSize = sizeof(name);
	name.lpszShortNameA = name.lpszLongNameA = appName;

	if(serverMode)
	{
		PrepareSLInfo(&sli);
		includeData = true;
	}
	
	// Create a player for us.
	if(FAILED(dPMaster->CreatePlayer(&lobbyId, &name, 
		NULL, includeData? &sli : NULL, 
		includeData? sizeof(sli) : 0,
		includeData? 0 : DPPLAYER_SPECTATOR)))
	{
		dPMaster->Close();
		return FALSE;
	}

	*success = true;

	// We're done here.
	return TRUE;
}

// When connecting to a master, a new thread starts here.
// The application can determine the status of the connection
// with JTNET_MASTER_CONNECTION.
void __cdecl MasterConnectThread(void *args)
{
	DPSESSIONDESC2 esd;
	HRESULT hr;
	bool success = false;

	memset(&esd, 0, sizeof(esd));
	esd.dwSize = sizeof(esd);
	esd.guidApplication = GUID_jtNetMaster;
	
	// Enumerate all the sessions. There will be only one, 
	// the master lobby.
	while((hr = dPMaster->EnumSessions(&esd, 0, Cb_ConnectToMaster,
		&success, DPENUMSESSIONS_AVAILABLE | DPENUMSESSIONS_RETURNSTATUS))
		== DPERR_CONNECTING) Sleep(5);

	// Check the final result.
	if(!success || hr != DP_OK) 
		masterConnection = JTNET_ERROR_CONNECT_FAILED;
	else
		// A connection has been formed.
		masterConnection = JTNET_OK;
}

// Enter the lobby. If the local player is a serverplayer, the server's
// name and description strings and player counts are included. Clients
// are flagged spectators in the master session.
int jtNetConnectMaster(void)
{
	// We won't reconnect.
	if(masterConnection == JTNET_OK) return JTNET_OK;

	// Make sure dPMaster is initialized.
	if(jtInitMaster() != JTNET_OK)
		return JTNET_ERROR_INIT_SERVICES;

	masterConnection = JTNET_ERROR_PLEASE_WAIT;

	_beginthread(MasterConnectThread, 0, 0);

	// Tell the caller that the connection is being formed.
	return JTNET_ERROR_PLEASE_WAIT;	
}

// Disconnect from the master server.
int jtNetDisconnectMaster(void)
{
	if(!dPMaster) return JTNET_ERROR_GENERIC;

	masterConnection = JTNET_ERROR_UNAVAILABLE;

	dPMaster->Close();
	dPMaster->Release();
	dPMaster = NULL;
	
	return JTNET_OK;
}

// Called by servers to update their data on the master.
void jtNetUpdateServerInfo(void)
{
	serverLobbyInfo_t sli;

	if(!dPMaster || !serverMode || masterConnection != JTNET_OK) 
		return;

	PrepareSLInfo(&sli);
	dPMaster->SetPlayerData(lobbyId, &sli, sizeof(sli), 
		DPSET_REMOTE | DPSET_GUARANTEED);
}

BOOL FAR PASCAL Cb_AppGroupFinder(DPID dpId, DWORD dwPlayerType, 
	LPCDPNAME lpName, DWORD dwFlags, LPVOID lpContext)
{
	groupenum_t *gen = (groupenum_t*) lpContext;

	if(dwPlayerType != DPPLAYERTYPE_GROUP) return TRUE;

	if(!strcmp(lpName->lpszShortNameA, gen->name->lpszShortNameA))
	{
		// A match! This is what we're looking for.
		gen->found = true;
		gen->id = dpId;
		return FALSE;
	}
	// Continue enumeration.
	return TRUE;
}

void ClearServerList(void)
{
	if(serverAddrs)
	{
		for(int i=0; i<numServers; i++)
			free(serverAddrs[i].dPlayAddress);
		free(serverAddrs);
		serverAddrs = NULL;
	}
	if(serverList) free(serverList);
	serverList = NULL;
	numServers = 0;
}

BOOL FAR PASCAL Cb_EnumServers(DPID dpId, DWORD dwPlayerType, 
	LPCDPNAME lpName, DWORD dwFlags, LPVOID lpContext)
{
	serverLobbyInfo_t sli;
	jtnetserver_t *svd;
	DPNAME *name = (DPNAME*) lpContext;
	//DWORD flags;

	if(dwPlayerType != DPPLAYERTYPE_PLAYER) return TRUE;
	if(dwFlags & DPENUMPLAYERS_SPECTATOR) return TRUE;

	// Do the names match?
	if(name && strcmp(lpName->lpszShortNameA, name->lpszShortNameA))
	{
		// Mismatch.
		return TRUE;
	}
	
	// Add this server to the list.
	serverList = (jtnetserver_t*) realloc(serverList, 
		sizeof(jtnetserver_t) * ++numServers);
	svd = serverList + numServers - 1;
	
	// Get the data.
	DWORD size = sizeof(sli);
	dPMaster->GetPlayerData(dpId, &sli, &size, 0);	
	
	strcpy(svd->app, lpName->lpszShortNameA);
	svd->serverId = dpId;
	strcpy(svd->name, sli.name);
	strcpy(svd->description, sli.description);
	svd->players = sli.players;
	svd->maxPlayers = sli.maxPlayers;
	svd->canJoin = sli.canJoin;
	svd->data[0] = sli.data[0];
	svd->data[1] = sli.data[1];
	svd->data[2] = sli.data[2];

	return TRUE;
}

// Enumerate servers for the given player.
// If playerId == DPID_SERVERPLAYER, all servers are enumerated.
void MasterEnumServers(DPID playerId)
{
	void *namebuf = NULL;
	DWORD size = 0;
	HRESULT hr;

#ifdef DEBUG
	dprintf( "jtNet: MasterEnumServers for %i", playerId);
#endif

	ClearServerList();
	if(!dPMaster) return;
	if(playerId != DPID_SERVERPLAYER)
	{
		// Get the app group name.
		do
		{
			hr = dPMaster->GetPlayerName(playerId, namebuf, &size);
			if(hr == DPERR_BUFFERTOOSMALL)
			{
				if(namebuf) free(namebuf);
				namebuf = malloc(size);
			}
		} while(hr == DPERR_BUFFERTOOSMALL);
	}
	dPMaster->EnumPlayers(NULL, Cb_EnumServers, namebuf, DPENUMPLAYERS_REMOTE);
	free(namebuf);
}

// Moves the given player to its application group.
void MoveToAppGroup(DPID id, DPNAME *name)
{
	groupenum_t gen;
	
	gen.found = false;
	gen.name = name;
	
	// Try to find the right application group.
	dPMaster->EnumGroups(NULL, Cb_AppGroupFinder, &gen, 0);

	if(!gen.found)
	{
		DPNAME grName;
		memset(&grName, 0, sizeof(grName));
		grName.dwSize = sizeof(grName);
		grName.lpszShortNameA = name->lpszShortNameA;
		// Then we need to create a new group.
		dPMaster->CreateGroup(&gen.id, &grName, NULL, 0, 0);
	}

	dPMaster->AddPlayerToGroup(gen.id, id);
}

void MasterSysMsgHandler(DPMSG_GENERIC *generic)
{
	if(generic->dwType == DPSYS_CREATEPLAYERORGROUP)
	{
		DPMSG_CREATEPLAYERORGROUP *msg = (DPMSG_CREATEPLAYERORGROUP*) generic;
		// We only handle player creation messages.
		if(msg->dwPlayerType != DPPLAYERTYPE_PLAYER) return;
		if(msg->lpData == NULL) return;
		MoveToAppGroup(msg->dpId, &msg->dpnName);
	}
}

// Not the wisest tactic to use this for building the message...
void AllocAndCopy(byte **buffer, DWORD *size, void *src, int addition)
{
	DWORD pos = *size;

	*size += addition;
	*buffer = (byte*) realloc(*buffer, *size);
	memcpy(*buffer + pos, src, addition);
}

// Composes a list of servers with DPlay addresses and sends it
// to the given player. Only the servers visible to the player
// are sent (app match).
void MasterSendServers(DPID to)
{
	byte	*buffer = NULL;
	DWORD	bufSize = 0, dpaSize; 
	int		i;
	void	*dpa;

	if(!dPMaster) return;
	
	// Enumerate the servers that are visible to the given player.
	MasterEnumServers(to);

	// First the type.
	i = MRQ_SERVERS;
	AllocAndCopy(&buffer, &bufSize, &i, 4);

	// First the number of servers included in the message.
	AllocAndCopy(&buffer, &bufSize, &numServers, 4);

#ifdef DEBUG
	dprintf( "jtNet: Sending servers, num=%i\n", numServers);
#endif

	for(i=0; i<numServers; i++)
	{
		AllocAndCopy(&buffer, &bufSize, serverList + i, sizeof(jtnetserver_t));
		
		// The DirectPlay address follows.
		dPMaster->GetPlayerAddress(serverList[i].serverId,
			NULL, &dpaSize);

		// Allocate memory for address and append it to the buffer.
		dpa = malloc(dpaSize);
		dPMaster->GetPlayerAddress(serverList[i].serverId, dpa, &dpaSize);
		AllocAndCopy(&buffer, &bufSize, &dpaSize, 4);
		AllocAndCopy(&buffer, &bufSize, dpa, dpaSize);
		free(dpa);
	}

	// The buffer now contains all the data.
	dPMaster->SendEx(lobbyId, to, DPSEND_ASYNC | DPSEND_GUARANTEED 
		| DPSEND_NOSENDCOMPLETEMSG, buffer, bufSize, 0, 0, NULL, NULL);

	// Free the buffer.
	free(buffer);
}

void MasterMsgHandler(DPID fromId, byte *msg, int length)
{
	int	request;

	// All messages sent to the master are requests for data.
	if(length != sizeof(int)) return;

	request = *(int*) msg;

	switch(request)
	{
	case MRQ_SERVERS:
		// Send the info and DPlay addresses of all the servers
		// in the player's app group.
		MasterSendServers(fromId);
		break;
	}
}

void MasterClientMsgHandler(byte *data, int length)
{
	int type = *(int*) data;
	int	i;

	// Move over the type ID.
	data += 4;

	if(type == MRQ_SERVERS)
	{
		// Get rid of the old list.
		ClearServerList();
		
		// The number of servers.
		numServers = *(int*) data;
		data += 4;
		
		// Allocate memory for the list.
		serverList = (jtnetserver_t*) malloc(sizeof(jtnetserver_t) * numServers);
		serverAddrs = (serverAddress_t*) malloc(sizeof(serverAddress_t) * numServers);
		
		for(i=0; i<numServers; i++)
		{
			jtnetserver_t *sv = serverList + i;
			serverAddress_t *sad = serverAddrs + i;
			// First read the info.
			memcpy(sv, data, sizeof(jtnetserver_t));
			data += sizeof(jtnetserver_t);
			// Then the address.
			sad->dpaSize = *(int*) data;
			data += 4;
			sad->dPlayAddress = malloc(sad->dpaSize);
			memcpy(sad->dPlayAddress, data, sad->dpaSize);
			data += sad->dpaSize;
		}
		
		// OK!
		listReceived = true;
	}
}

// Handles the messages received by the master. Called periodically by 
// the master lobby program and the client (while retrieving data from
// the master).
void jtNetMasterHandler(void)
{
	byte *buffer = NULL;
	DWORD bufsize = 0;
	DPID fromId, toId;
	HRESULT hr;

	if(!dPMaster) return;

	do 
	{
		// Loop until a message is successfully read.
		do 
		{
			hr = dPMaster->Receive(&fromId, &toId, 0, buffer, &bufsize);
			if(hr == DPERR_BUFFERTOOSMALL)
			{
				if(buffer) delete [] buffer;
				buffer = new byte[bufsize];
			}
		} while(hr == DPERR_BUFFERTOOSMALL);
		// Did we get a message?		
		if(SUCCEEDED(hr))
		{
			if(lobbyId == DPID_SERVERPLAYER)
			{
				if(fromId == DPID_SYSMSG)
					MasterSysMsgHandler( (DPMSG_GENERIC*) buffer);
				else
					MasterMsgHandler(fromId, buffer, bufsize);
			}
			else
			{
				if(fromId == DPID_SERVERPLAYER)
				{
					// Lobby clients handle packets on their own.
					MasterClientMsgHandler(buffer, bufsize);
				}
			}
		}
	} while(SUCCEEDED(hr));
	// Delete the buffer.
	if(buffer) delete [] buffer;
}

int jtSendRequest(int request)
{
	HRESULT hr;

	if(!dPMaster || lobbyId == DPID_SERVERPLAYER) 
		return JTNET_ERROR_GENERIC;

	hr = dPMaster->SendEx(lobbyId, DPID_SERVERPLAYER,
		DPSEND_ASYNC | DPSEND_NOSENDCOMPLETEMSG | DPSEND_GUARANTEED,
		&request, sizeof(request),
		0, 0, NULL, NULL);

	if(FAILED(hr) && hr != DPERR_PENDING)
		return JTNET_ERROR_SEND_FAILED;

	return JTNET_OK;
}

// If the buffer is NULL, the list of servers is enumerated and
// the number of servers is returned. The caller can then retrieve 
// the data for each server by calling this function with indices 
// beginning from zero until JTNET_ERROR_BAD_INDEX is returned.
int jtNetMasterGetServer(int index, jtnetserver_t *buffer)
{
	// Should we enumerate?
	if(!buffer)
	{	
		if(!dPMaster) return JTNET_ERROR_GENERIC;
		// Only the master enumerates.
		if(lobbyId == DPID_SERVERPLAYER)
		{
			MasterEnumServers(lobbyId);
			return numServers;
		}
		else
		{
			// We're just visiting, request a list of servers.
			listReceived = false;
			return jtSendRequest(MRQ_SERVERS);
		}
	}
	// Check the index.
	if(index < 0 || index >= numServers) 
		return JTNET_ERROR_BAD_INDEX;
	// Copy the data and we're done.
	memcpy(buffer, serverList + index, sizeof(jtnetserver_t));
	return JTNET_OK;
}

// Try to connect to a server on the list of servers retrieved 
// from the master.
int jtNetConnectIdx(int index)
{
	// Check the index.
	if(index < 0 || index >= numServers) 
		return JTNET_ERROR_BAD_INDEX;

	// Force a new connection.
	connectionInitOk = false;
	
	if(jtValidateConnectionEx(serverAddrs[index].dPlayAddress) != JTNET_OK)
		return JTNET_ERROR_GENERIC;

	jtEnumerateSessions(true);
	return jtConnect(&sessions[0].desc);
}