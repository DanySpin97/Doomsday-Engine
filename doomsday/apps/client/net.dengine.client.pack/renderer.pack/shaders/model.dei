model.skeletal {
    # Shader for skeletal animation and generic per-pixel lighting:
    # diffuse color, normal map, emissive map, specular intensity.
    shader generic {
        variable uAlpha      { value = 1 }
        variable uAlphaLimit { value = 0 }
        variable uEmission   { value = 0 }
        
        # Mapping when used with ModelDrawable.
        textureMapping <diffuse, normals, specular, emission>
        
        include.vertex <include/tangentspace.glsl,
                        include/skeletal.glsl,
                        include/lighting.glsl>
        vertex = "
            uniform highp mat4 uMvpMatrix;

            attribute highp vec4 aVertex;
            attribute highp vec2 aUV;
            attribute highp vec4 aBounds;   // diffuse map
            attribute highp vec4 aBounds2;  // normal map
            attribute highp vec4 aBounds3;  // specular map
            attribute highp vec4 aBounds4;  // emission map

            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[4];

            void main(void) 
            {
                highp mat4 bone = vertexBoneTransform();
                highp mat3 surface = tangentSpace(bone);
                calculateSurfaceLighting(surface);
                    
                // Vertex position.
                highp vec4 modelPos = bone * aVertex;
                gl_Position = uMvpMatrix * modelPos;
                                
                // Eye direction in tangent space.
                calculateEyeDirection(modelPos, surface);
                          
                vUV = aUV;
                vUVBounds[0] = aBounds;
                vUVBounds[1] = aBounds2;
                vUVBounds[2] = aBounds3;
                vUVBounds[3] = aBounds4;
            }"

        include.fragment <include/texture.glsl, 
                          include/lighting.glsl,
                          include/fog.glsl>
        fragment = "
            uniform highp float uAlpha;
            uniform highp float uAlphaLimit; // alpha test to discard fragments
            
            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[4];
            
            void main(void) 
            {
                // Calculate UV at the fragment (wrapped inside the bounds).
                highp vec2 wrappedUV = fract(vUV);
                highp vec2 uv         = mapToBounds(wrappedUV, vUVBounds[0]);
                highp vec2 normalUV   = mapToBounds(wrappedUV, vUVBounds[1]);
                highp vec2 specularUV = mapToBounds(wrappedUV, vUVBounds[2]);
                highp vec2 emissiveUV = mapToBounds(wrappedUV, vUVBounds[3]);
            
                highp vec3 normal = normalVector(normalUV);
                
                highp vec4 diffuse = texture2D(uTex, uv);
                diffuse.a *= uAlpha;
                        
                gl_FragColor = diffuse * diffuseLight(normal);

                highp vec4 specular = specularLight(specularUV, normal);
                gl_FragColor.rgb += specular.rgb;

                gl_FragColor += emittedLight(emissiveUV);

                // Specular reflections show up on transparent surfaces.
                gl_FragColor.a = min(1.0, diffuse.a + specular.a);

                if(gl_FragColor.a < uAlphaLimit) discard;
                    
                applyFog();
            }"
    }
    
    # Shader for damage/blood effects. No emissive map, and alpha 
    # output is either opaque or fully transparent. Alpha limit can 
    # be used to control how much of the effect is visible.
    shader blood {
        variable uAlphaLimit { value = 0.5 }

        # Mapping when used with ModelDrawable.
        textureMapping <diffuse, normals, specular>
        
        include.vertex <include/tangentspace.glsl,
                        include/skeletal.glsl,
                        include/lighting.glsl>
        vertex = "
            uniform highp mat4 uMvpMatrix;

            attribute highp vec4 aVertex;
            attribute highp vec2 aUV;
            attribute highp vec4 aBounds;   // diffuse map
            attribute highp vec4 aBounds2;  // normal map
            attribute highp vec4 aBounds3;  // specular map

            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[3];

            void main(void) 
            {
                highp mat4 bone = vertexBoneTransform();
                highp mat3 surface = tangentSpace(bone);
                calculateSurfaceLighting(surface);
                    
                // Vertex position.
                highp vec4 modelPos = bone * aVertex;
                gl_Position = uMvpMatrix * modelPos;
                                
                // Eye direction in tangent space.
                calculateEyeDirection(modelPos, surface);
                          
                vUV = aUV;
                vUVBounds[0] = aBounds;
                vUVBounds[1] = aBounds2;
                vUVBounds[2] = aBounds3;
            }"

        include.fragment <include/texture.glsl, 
                          include/lighting.glsl,
                          include/fog.glsl>
        fragment = "
            uniform highp float uAlphaLimit;
            
            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[3];
            
            void main(void) 
            {
                // Calculate UV at the fragment (wrapped inside the bounds).
                highp vec2 wrappedUV = fract(vUV);
                highp vec2 uv         = mapToBounds(wrappedUV, vUVBounds[0]);
                highp vec2 normalUV   = mapToBounds(wrappedUV, vUVBounds[1]);
                highp vec2 specularUV = mapToBounds(wrappedUV, vUVBounds[2]);
            
                highp vec4 diffuse = texture2D(uTex, uv);
                if(diffuse.a < uAlphaLimit) discard;
                
                highp vec3 normal = normalVector(normalUV);                
                gl_FragColor = diffuse * diffuseLight(normal);

                highp vec4 specular = specularLight(specularUV, normal);
                gl_FragColor.rgb += specular.rgb;

                // All accepted fragments are opaque.
                gl_FragColor.a = 1.0;
                
                applyFog();
            }"        
    }    
}
