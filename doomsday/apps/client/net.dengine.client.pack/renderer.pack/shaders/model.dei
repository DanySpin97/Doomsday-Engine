model {
    # Shader for skeletal animation and generic per-pixel lighting:
    # diffuse color, normal map, emission map, specular intensity.
    shader skeletal.normal_specular_emission {
        variable uAlpha      { value = 1 }
        variable uAlphaLimit { value = 0 }
        variable uEmission   { value = 0 }
        # Mapping when used with ModelDrawable.
        textureMapping <diffuse, normals, specular, emission>
        vertex = "
            uniform highp mat4 uMvpMatrix;
            uniform highp mat4 uBoneMatrices[64];
            uniform highp vec3 uLightDirs[4];
            uniform highp vec3 uEyePos;

            attribute highp vec4 aVertex;
            attribute highp vec3 aNormal;
            attribute highp vec3 aTangent;
            attribute highp vec3 aBitangent;
            attribute highp vec2 aUV;
            attribute highp vec4 aBounds;   // diffuse map
            attribute highp vec4 aBounds2;  // normal map
            attribute highp vec4 aBounds3;  // specular map
            attribute highp vec4 aBounds4;  // emission map
            attribute highp vec4 aBoneIDs;
            attribute highp vec4 aBoneWeights;

            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[4];
            varying highp vec3 vLightDirs[4]; // tangent space
            varying highp vec3 vEyeDir;       // tangent space

            highp vec3 transformVector(highp vec3 dir, highp mat4 matrix) 
            {
                return (matrix * vec4(dir, 0.0)).xyz;
            }

            void main(void) 
            {
                // Bone transformation.
                highp mat4 bone =
                    uBoneMatrices[int(aBoneIDs.x + 0.5)] * aBoneWeights.x +
                    uBoneMatrices[int(aBoneIDs.y + 0.5)] * aBoneWeights.y +
                    uBoneMatrices[int(aBoneIDs.z + 0.5)] * aBoneWeights.z +
                    uBoneMatrices[int(aBoneIDs.w + 0.5)] * aBoneWeights.w;
                    
                // Vertex position.
                highp vec4 modelPos = bone * aVertex;
                gl_Position = uMvpMatrix * modelPos;
                
                // Tangent space.
                highp vec3 normal       = transformVector(aNormal, bone);
                highp vec3 tangent      = transformVector(aTangent, bone);
                highp vec3 bitangent    = transformVector(aBitangent, bone);
                highp mat3 tangentSpace = mat3(tangent, bitangent, normal);
                
                // Light direction in tangent space.
                vLightDirs[0] = uLightDirs[0] * tangentSpace;
                vLightDirs[1] = uLightDirs[1] * tangentSpace;
                vLightDirs[2] = uLightDirs[2] * tangentSpace;
                vLightDirs[3] = uLightDirs[3] * tangentSpace;
                
                // Eye direction in tangent space.
                vEyeDir = (uEyePos - modelPos.xyz/modelPos.w) * tangentSpace;
                          
                vUV = aUV;
                vUVBounds[0] = aBounds;
                vUVBounds[1] = aBounds2;
                vUVBounds[2] = aBounds3;
                vUVBounds[3] = aBounds4;
            }"
        fragment = "
            uniform sampler2D uTex;
            uniform highp vec4 uAmbientLight;
            uniform highp vec4 uLightIntensities[4];        
            uniform highp float uEmission;
            uniform highp float uAlpha;
            uniform highp float uAlphaLimit; // alpha test to discard fragments
            
            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[4];
            varying highp vec3 vLightDirs[4]; // tangent space
            varying highp vec3 vEyeDir;       // tangent space
            
            highp vec3 normalVector(highp vec2 uv) 
            {
                return normalize((texture2D(uTex, uv).xyz * 2.0) - 1.0);
            }

            highp vec4 diffuseLight(int index, highp vec3 normal) 
            {
                if(uLightIntensities[index].a <= 0.001) 
                {
                    return vec4(0.0); // too dim
                }
                highp float d = dot(normal, normalize(vLightDirs[index]));
                return max(d * uLightIntensities[index], vec4(0.0));
            }
            
            highp vec4 specularLight(highp vec2 specularUV, int index, highp vec3 normal) 
            {
                if(uLightIntensities[index].a <= 0.001) 
                {
                    return vec4(0.0); // too dim
                }

                // Is the surface facing the light direction?
                highp float facing = smoothstep(0.0, 0.2, dot(vLightDirs[index], normal));
                if(facing <= 0.0)
                {
                    return vec4(0.0); // wrong way
                }
                
                highp vec3 reflected = reflect(-vLightDirs[index], normal);
                
                // Check the specular texture for parameters.
                highp vec4 specular = texture2D(uTex, specularUV);
                highp float shininess = max(1.0, specular.a * 7.0);
                
                highp float d =  
                    facing * 
                    dot(normalize(vEyeDir), reflected) * 
                    shininess - max(0.0, shininess - 1.0);
                return max(0.0, d) * 
                    uLightIntensities[index] * 
                    vec4(specular.rgb * 2.0, max(max(specular.r, specular.g), specular.b));
            }
            
            void main(void) 
            {
                // Calculate UV at the fragment (wrapped inside the bounds).
                highp vec2 wrappedUV = fract(vUV);
                highp vec2 uv         = vUVBounds[0].xy + wrappedUV * vUVBounds[0].zw;
                highp vec2 normalUV   = vUVBounds[1].xy + wrappedUV * vUVBounds[1].zw;
                highp vec2 specularUV = vUVBounds[2].xy + wrappedUV * vUVBounds[2].zw;
                highp vec2 emissiveUV = vUVBounds[3].xy + wrappedUV * vUVBounds[3].zw;
            
                highp vec3 normal = normalVector(normalUV);
                highp vec4 diffuse = texture2D(uTex, uv);
                diffuse.a *= uAlpha;
                        
                gl_FragColor = diffuse *
                    (uAmbientLight + 
                     diffuseLight(0, normal) + 
                     diffuseLight(1, normal) + 
                     diffuseLight(2, normal) + 
                     diffuseLight(3, normal));

                highp vec4 specular =
                    specularLight(specularUV, 0, normal) +
                    specularLight(specularUV, 1, normal) +
                    specularLight(specularUV, 2, normal) +
                    specularLight(specularUV, 3, normal);
                    
                highp vec4 emission = uEmission * texture2D(uTex, emissiveUV);
                    
                gl_FragColor.rgb += specular.rgb + emission.rgb;
                gl_FragColor.a = min(1.0, diffuse.a + specular.a);

                if(gl_FragColor.a < uAlphaLimit) discard;
            }"
    }
}
