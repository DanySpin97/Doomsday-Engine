model {
    # Shader for skeletal animation and generic per-pixel lighting:
    # diffuse color, normal map, emission map, specular intensity.
    shader skeletal.normal_specular_emission {
        variable uAlpha      { value = 1 }
        variable uAlphaLimit { value = 0 }
        variable uEmission   { value = 0 }
        
        # Mapping when used with ModelDrawable.
        textureMapping <diffuse, normals, specular, emission>
        
        include.vertex <include/skeletal.glsl,
                        include/lighting.glsl>
        vertex = "
            uniform highp mat4 uMvpMatrix;
            uniform highp vec3 uEyePos;

            attribute highp vec4 aVertex;
            attribute highp vec3 aNormal;
            attribute highp vec3 aTangent;
            attribute highp vec3 aBitangent;
            attribute highp vec2 aUV;
            attribute highp vec4 aBounds;   // diffuse map
            attribute highp vec4 aBounds2;  // normal map
            attribute highp vec4 aBounds3;  // specular map
            attribute highp vec4 aBounds4;  // emission map

            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[4];

            highp vec3 transformVector(highp vec3 dir, highp mat4 matrix) 
            {
                return (matrix * vec4(dir, 0.0)).xyz;
            }

            void main(void) 
            {
                highp mat4 bone = vertexBoneTransform();
                    
                // Vertex position.
                highp vec4 modelPos = bone * aVertex;
                gl_Position = uMvpMatrix * modelPos;
                
                // Tangent space.
                highp vec3 normal       = transformVector(aNormal, bone);
                highp vec3 tangent      = transformVector(aTangent, bone);
                highp vec3 bitangent    = transformVector(aBitangent, bone);
                highp mat3 tangentSpace = mat3(tangent, bitangent, normal);
                
                // Light direction in tangent space.
                vLightDirs[0] = uLightDirs[0] * tangentSpace;
                vLightDirs[1] = uLightDirs[1] * tangentSpace;
                vLightDirs[2] = uLightDirs[2] * tangentSpace;
                vLightDirs[3] = uLightDirs[3] * tangentSpace;
                
                // Eye direction in tangent space.
                vEyeDir = (uEyePos - modelPos.xyz/modelPos.w) * tangentSpace;
                          
                vUV = aUV;
                vUVBounds[0] = aBounds;
                vUVBounds[1] = aBounds2;
                vUVBounds[2] = aBounds3;
                vUVBounds[3] = aBounds4;
            }"

        include.fragment <include/texture.glsl, 
                          include/lighting.glsl>
        fragment = "
            uniform highp float uAlpha;
            uniform highp float uAlphaLimit; // alpha test to discard fragments
            
            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[4];
            
            void main(void) 
            {
                // Calculate UV at the fragment (wrapped inside the bounds).
                highp vec2 wrappedUV = fract(vUV);
                highp vec2 uv         = mapToBounds(wrappedUV, vUVBounds[0]);
                highp vec2 normalUV   = mapToBounds(wrappedUV, vUVBounds[1]);
                highp vec2 specularUV = mapToBounds(wrappedUV, vUVBounds[2]);
                highp vec2 emissiveUV = mapToBounds(wrappedUV, vUVBounds[3]);
            
                highp vec3 normal = normalVector(normalUV);
                
                highp vec4 diffuse = texture2D(uTex, uv);
                diffuse.a *= uAlpha;
                        
                gl_FragColor = diffuse * diffuseLight(normal);

                highp vec4 specular = specularLight(specularUV, normal);
                gl_FragColor.rgb += specular.rgb;

                gl_FragColor += emittedLight(emissiveUV);

                // Specular reflections show up on transparent surfaces.
                gl_FragColor.a = min(1.0, diffuse.a + specular.a);

                if(gl_FragColor.a < uAlphaLimit) discard;
            }"
    }
}
