model.skeletal {
    # Shader for skeletal animation and generic per-pixel lighting:
    # diffuse color, normal map, emissive map, specular intensity.
    # Also supports uMapTime and a custom UV macro.
    shader generic {
        variable uAlphaLimit     { value = 0 }
        variable uAlpha          { value = 1 }
        variable uColor          { value <1, 1, 1> }
        variable uOffsetUV       { value <0, 0> }
        variable uSpecular       { value = 3 }
        variable uEmission       { value = 0 }
        variable uGlossiness     { value = 100 }
        variable uReflectionBlur { value = 10 }

        variable uMapTime {}
        
        # Mapping when used with ModelDrawable.
        textureMapping <diffuse, normals, specular, emission>
        
        include.vertex <include/tangentspace.glsl,
                        include/skeletal.glsl,
                        include/lighting.glsl>
        vertex = "
            uniform highp mat4 uMvpMatrix;

            attribute highp vec4 aVertex;
            attribute highp vec4 aColor;
            attribute highp vec2 aUV;
            attribute highp vec4 aBounds;   // diffuse map
            attribute highp vec4 aBounds2;  // normal map
            attribute highp vec4 aBounds3;  // specular map
            attribute highp vec4 aBounds4;  // emission map

            varying highp vec4 vColor;
            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[4];

            void main(void) 
            {
                highp mat4 bone = vertexBoneTransform();
                setTangentSpace(bone);
                    
                // Vertex position.
                highp vec4 modelPos = bone * aVertex;
                calculateEyeDirection(modelPos);
                
                gl_Position = uMvpMatrix * modelPos;
                          
                vColor = aColor;
                vUV = aUV;
                vUVBounds[0] = aBounds;
                vUVBounds[1] = aBounds2;
                vUVBounds[2] = aBounds3;
                vUVBounds[3] = aBounds4;                
            }"

        defines $= {'PREDEF_TRANSFORM_UV(uv)': ''}
        
        include.fragment <include/texture.glsl, 
                          include/tangentspace.glsl,
                          include/lighting.glsl,
                          include/reflection.glsl,
                          include/fog.glsl>
        fragment = "
            uniform highp vec3 uColor;       // diffuse color multiplier
            uniform highp float uAlpha;      // diffuse alpha multiplier
            uniform highp float uAlphaLimit; // alpha test to discard fragments
            uniform highp vec2 uOffsetUV;
            uniform highp float uMapTime;            
            
            varying highp vec4 vColor;
            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[4];
            
            void main(void) 
            {
                // Calculate UV at the fragment (wrapped inside the bounds).
                highp vec2 wrappedUV = vUV + uOffsetUV;
                PREDEF_TRANSFORM_UV(wrappedUV);
                wrappedUV = fract(wrappedUV);
                highp vec2 uv         = mapToBounds(wrappedUV, vUVBounds[0]);
                highp vec2 normalUV   = mapToBounds(wrappedUV, vUVBounds[1]);
                highp vec2 specularUV = mapToBounds(wrappedUV, vUVBounds[2]);
                highp vec2 emissiveUV = mapToBounds(wrappedUV, vUVBounds[3]);
            
                highp vec3 msNormal = modelSpaceNormalVector(normalUV);
                highp vec4 specGloss = specularGloss(specularUV);
                
                gl_FragColor = diffuseAndReflectedLight(
                    vColor * vec4(uColor, uAlpha), uv, specGloss, msNormal);

                if(gl_FragColor.a < uAlphaLimit) discard;

                gl_FragColor.rgb += specularLight(specGloss, msNormal);
                gl_FragColor += emittedLight(emissiveUV);
                    
                applyFog();
            }"
    }
    
    # Variant of the generic shader that is suitable for opaque objects 
    # with no transparency.    
    shader opaque.generic inherits model.skeletal.generic {
        variable uAlphaLimit { value = 0.5 }
        fragment = "
            uniform highp vec3 uColor;       // diffuse color multiplier
            uniform highp float uAlpha;
            uniform highp float uAlphaLimit; // alpha test to discard fragments
            uniform highp vec2 uOffsetUV;
        
            varying highp vec4 vColor;
            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[4];
        
            void main(void) 
            {
                // Calculate UV at the fragment (wrapped inside the bounds).
                highp vec2 wrappedUV = fract(vUV + uOffsetUV);
                highp vec2 uv         = mapToBounds(wrappedUV, vUVBounds[0]);
                highp vec2 normalUV   = mapToBounds(wrappedUV, vUVBounds[1]);
                highp vec2 specularUV = mapToBounds(wrappedUV, vUVBounds[2]);
                highp vec2 emissiveUV = mapToBounds(wrappedUV, vUVBounds[3]);
        
                highp vec3 msNormal = modelSpaceNormalVector(normalUV);
                highp vec4 specGloss = specularGloss(specularUV);
                
                gl_FragColor = diffuseAndReflectedLight(
                    vColor * vec4(uColor, uAlpha), uv, specGloss, msNormal);

                if(gl_FragColor.a < uAlphaLimit) discard;
            
                gl_FragColor.rgb += specularLight(specGloss, msNormal);
                gl_FragColor += emittedLight(emissiveUV);
                
                applyFog();
            }"
    }
    
    # Shader for damage/blood effects. No emissive map, and alpha 
    # output is either opaque or fully transparent. Alpha limit can 
    # be used to control how much of the effect is visible.
    shader opaque.nonemissive {
        variable uAlphaLimit     { value = 0.5 }
        variable uAlpha          { value = 1.0 }
        variable uColor          { value <1, 1, 1> }
        variable uOffsetUV       { value <0, 0> }
        variable uSpecular       { value = 3 }
        variable uGlossiness     { value = 100 }
        variable uReflectionBlur { value = 10 }

        # Mapping when used with ModelDrawable.
        textureMapping <diffuse, normals, specular>
        
        include.vertex <include/tangentspace.glsl,
                        include/skeletal.glsl,
                        include/lighting.glsl>
        vertex = "
            uniform highp mat4 uMvpMatrix;

            attribute highp vec4 aVertex;
            attribute highp vec4 aColor;
            attribute highp vec2 aUV;
            attribute highp vec4 aBounds;   // diffuse map
            attribute highp vec4 aBounds2;  // normal map
            attribute highp vec4 aBounds3;  // specular map

            varying highp vec4 vColor;
            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[3];

            void main(void) 
            {
                highp mat4 bone = vertexBoneTransform();
                setTangentSpace(bone);
                    
                // Vertex position.
                highp vec4 modelPos = bone * aVertex;
                calculateEyeDirection(modelPos);

                gl_Position = uMvpMatrix * modelPos;
                          
                vColor = aColor;
                vUV = aUV;
                vUVBounds[0] = aBounds;
                vUVBounds[1] = aBounds2;
                vUVBounds[2] = aBounds3;                
            }"

        include.fragment <include/texture.glsl, 
                          include/tangentspace.glsl,
                          include/lighting.glsl,
                          include/reflection.glsl,
                          include/fog.glsl>
        fragment = "
            uniform highp float uAlphaLimit;
            uniform highp float uAlpha;
            uniform highp vec3 uColor;       // diffuse color multiplier
            uniform highp vec2 uOffsetUV;
            
            varying highp vec4 vColor;
            varying highp vec2 vUV;
            varying highp vec4 vUVBounds[3];
            
            void main(void) 
            {
                // Calculate UV at the fragment (wrapped inside the bounds).
                highp vec2 wrappedUV = fract(vUV + uOffsetUV);
                highp vec2 uv         = mapToBounds(wrappedUV, vUVBounds[0]);
                highp vec2 normalUV   = mapToBounds(wrappedUV, vUVBounds[1]);
                highp vec2 specularUV = mapToBounds(wrappedUV, vUVBounds[2]);
            
                highp vec3 msNormal = modelSpaceNormalVector(normalUV);
                highp vec4 specGloss = specularGloss(specularUV);
                
                gl_FragColor = diffuseAndReflectedLight(
                    vColor * vec4(uColor, uAlpha), uv, specGloss, msNormal);
                if(gl_FragColor.a < uAlphaLimit) discard;

                gl_FragColor.rgb += specularLight(specGloss, msNormal);

                gl_FragColor.a = uAlpha;
                
                applyFog();
            }"        
    }
    
    # Shader for special effects. Only uses a diffuse texture map.
    # No external lighting.
    shader unlit.diffuse {
        variable uAlphaLimit { value = 0 }
        variable uAlpha      { value = 1.0 }
        variable uColor      { value <1, 1, 1> }
        variable uOffsetUV   { value <0, 0> }

        # Mapping when used with ModelDrawable.
        textureMapping <diffuse>
        
        include.vertex <include/skeletal.glsl>
        vertex = "
            uniform highp mat4 uMvpMatrix;

            attribute highp vec4 aVertex;
            attribute highp vec4 aColor;
            attribute highp vec2 aUV;
            attribute highp vec4 aBounds;   // diffuse map

            varying highp vec4 vColor;
            varying highp vec2 vUV;
            varying highp vec4 vUVBounds;

            void main(void) 
            {
                highp mat4 bone = vertexBoneTransform();
                    
                // Vertex position.
                highp vec4 modelPos = bone * aVertex;
                gl_Position = uMvpMatrix * modelPos;
                                                          
                vColor = aColor;
                vUV = aUV;
                vUVBounds = aBounds;
            }"

        include.fragment <include/texture.glsl>
        fragment = "
            uniform highp float uAlphaLimit;
            uniform highp float uAlpha;
            uniform highp vec3 uColor;       // diffuse color multiplier
            uniform highp vec2 uOffsetUV;
            
            varying highp vec4 vColor;
            varying highp vec2 vUV;
            varying highp vec4 vUVBounds;
            
            void main(void) 
            {
                // Calculate UV at the fragment (wrapped inside the bounds).
                highp vec2 wrappedUV = fract(vUV + uOffsetUV);
                highp vec2 uv = mapToBounds(wrappedUV, vUVBounds);
            
                highp vec4 diffuse = vColor * texture2D(uTex, uv);
                if(diffuse.a < uAlphaLimit) discard;
                
                gl_FragColor = diffuse * vec4(uColor, uAlpha);
            }"        
    }        
}
