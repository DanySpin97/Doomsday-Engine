/**\file
 *\section License
 * License: GPL
 * Online License Link: http://www.gnu.org/licenses/gpl.html
 *
 *\author Copyright © 2003-2007 Jaakko Keränen <jaakko.keranen@iki.fi>
 *\author Copyright © 2006-2007 Daniel Swanson <danij@dengine.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301  USA
 */

/**
 * dam_read.c: Doomsday Archived Map (DAM).
 *
 * Binary lump reader and custom property management.
 */

// HEADER FILES ------------------------------------------------------------

#include "de_base.h"
#include "de_dam.h"
#include "de_defs.h"
#include "de_misc.h"
#include "de_refresh.h"

#include "p_mapdata.h"

// MACROS ------------------------------------------------------------------

// TYPES -------------------------------------------------------------------

/**
 * Registered by the game during init, these are used by DAM when reading
 * the map lump data as well as the DDay internal data types. The data is
 * read by DDay and any type/size/endian conversion is done before being
 * passed to the game to deal with.
 */
typedef struct {
    uint        id;
    int         type;       // DAM Object type e.g. DAM_SECTOR
    int         datatype;   // e.g. DDVT_INT
    char        name[DED_STRINGID_LEN + 1];
} mapproperty_t;

typedef struct {
    gamemap_t  *map;
    size_t      elmsize;
    uint        elements;
    uint        numProps;
    readprop_t *props;
} damlumpreadargs_t;

typedef struct setargs_s {
    gamemap_t  *map;
    int         type;
    uint        prop;

    valuetype_t valueType;
    boolean    *booleanValues;
    byte       *byteValues;
    short      *shortValues;
    int        *intValues;
    uint       *uintValues;
    fixed_t    *fixedValues;
    long       *longValues;
    unsigned long *ulongValues;
    float      *floatValues;
    angle_t    *angleValues;
    void      **ptrValues;
} damsetargs_t;

// EXTERNAL FUNCTION PROTOTYPES --------------------------------------------

void *DAM_IndexToPtr(gamemap_t *map, int objectType, uint id);

// PUBLIC FUNCTION PROTOTYPES ----------------------------------------------

// PRIVATE FUNCTION PROTOTYPES ---------------------------------------------

static int ReadAndCallback(int dataType, unsigned int startIndex,
                           const byte *buffer, void* context,
                           int (*callback)(int type, uint index, void* ctx));

// EXTERNAL DATA DECLARATIONS ----------------------------------------------

// PUBLIC DATA DEFINITIONS -------------------------------------------------

// PRIVATE DATA DEFINITIONS ------------------------------------------------

// Custom map properties.
static boolean canRegisterProps = false;
static uint numTotalCustomProps;
static mapproperty_t *customProps[DAM_SECTOR];
static uint numCustomProps[DAM_SECTOR];

// \todo this array should be generated by the mapdata.hs script.
#define DAM_NUM_PROPERTIES 22
static mapproperty_t properties[DAM_NUM_PROPERTIES] =
{
// Vertex
    {DAM_X, DAM_VERTEX, DMT_VERTEX_POS, "x"},
    {DAM_Y, DAM_VERTEX, DMT_VERTEX_POS, "y"},
// Line
    // \todo should be DMT_LINE_V but we require special case logic
    {DAM_VERTEX1, DAM_LINE, DDVT_VERT_IDX, "vertex1"},
    {DAM_VERTEX2, DAM_LINE, DDVT_VERT_IDX, "vertex2"},
    {DAM_FLAGS, DAM_LINE, DMT_LINE_MAPFLAGS, "flags"},
    // \todo should be DMT_LINE_SIDES but we require special case logic
    {DAM_SIDE0, DAM_LINE, DDVT_SIDE_IDX, "frontside"},
    // \todo should be DMT_LINE_SIDES but we require special case logic
    {DAM_SIDE1, DAM_LINE, DDVT_SIDE_IDX, "backside"},
// Side
    {DAM_TOP_MATERIAL_OFFSET_X, DAM_SIDE, DMT_SURFACE_OFFSET, "toptextureoffsetx"},
    {DAM_TOP_MATERIAL_OFFSET_Y, DAM_SIDE, DMT_SURFACE_OFFSET, "toptextureoffsety"},
    {DAM_MIDDLE_MATERIAL_OFFSET_X, DAM_SIDE, DMT_SURFACE_OFFSET, "middletextureoffsetx"},
    {DAM_MIDDLE_MATERIAL_OFFSET_Y, DAM_SIDE, DMT_SURFACE_OFFSET, "middletextureoffsety"},
    {DAM_BOTTOM_MATERIAL_OFFSET_X, DAM_SIDE, DMT_SURFACE_OFFSET, "bottomtextureoffsetx"},
    {DAM_BOTTOM_MATERIAL_OFFSET_Y, DAM_SIDE, DMT_SURFACE_OFFSET, "bottomtextureoffsety"},
    {DAM_TOP_MATERIAL, DAM_SIDE, DMT_MATERIAL, "toptexture"},
    {DAM_MIDDLE_MATERIAL, DAM_SIDE, DMT_MATERIAL, "middletexture"},
    {DAM_BOTTOM_MATERIAL, DAM_SIDE, DMT_MATERIAL, "bottomtexture"},
    // \todo should be DMT_SIDE_SECTOR but we require special case logic
    {DAM_FRONT_SECTOR, DAM_SIDE, DDVT_SECT_IDX, "frontsector"},
// Sector
    {DAM_FLOOR_HEIGHT, DAM_SECTOR, DMT_PLANE_HEIGHT, "floorheight"},
    {DAM_CEILING_HEIGHT, DAM_SECTOR, DMT_PLANE_HEIGHT, "ceilingheight"},
    {DAM_FLOOR_MATERIAL, DAM_SECTOR, DMT_MATERIAL, "floortexture"},
    {DAM_CEILING_MATERIAL, DAM_SECTOR, DMT_MATERIAL, "ceilingtexture"},
    {DAM_LIGHT_LEVEL, DAM_SECTOR, DDVT_SHORT, "lightlevel"},
};

// CODE --------------------------------------------------------------------

/**
 * Called during engine startup to make ready for the registration of
 * properties to be read from archived map data.
 */
void DAM_InitReader(void)
{
    uint        i;

    canRegisterProps = true;
    for(i = 0; i < DAM_SECTOR; ++i)
    {
        numCustomProps[i] = 0;
        customProps[i] = NULL;
    }
    numTotalCustomProps = 0;
}

void DAM_LockCustomPropertys(void)
{
    // We're now closed for business.
    canRegisterProps = false;
}

/**
 * Does the specified DAM object type support custom properites?
 *
 * @param type      DAM object, type identifier e.g. @c DAM_SIDE to check
 *                  for custom property support.
 * @return          @c true, if the map object supports custom properties.
 */
boolean DAM_TypeSupportsCustomProperty(int type)
{
    switch(type)
    {
    case DAM_THING:
    case DAM_VERTEX:
    case DAM_LINE:
    case DAM_SIDE:
    case DAM_SECTOR:
        return true;

    default:
        break;
    }

    return false;
}

uint DAM_IDForProperty(int type, char *name)
{
    uint        i, propID = 0;
    boolean     found = false;

    // Check built-in properties first.
    if(DAM_NUM_PROPERTIES > 0)
    {
        mapproperty_t *ptr = properties;
        i = 0;
        do
        {
            if(ptr->type == type && !stricmp(ptr->name, name))
            {
                propID = ptr->id;
                found = true;
            }
            else
            {
                i++;
                ptr++;
            }
        } while(!found && i < DAM_NUM_PROPERTIES);
    }

    // Check custom properties.
    if(!found && DAM_TypeSupportsCustomProperty(type))
    {
        uint        id = type - 1;
        if(numCustomProps[id] > 0)
        {
            mapproperty_t *ptr = customProps[id];
            i = 0;
            do
            {
                if(!stricmp(name, ptr->name))
                {
                    propID = ptr->id;
                    found = true;
                }
                else
                {
                    i++;
                    ptr++;
                }
            } while(!found && i < numCustomProps[id]);
        }
    }

    return propID;
}

/**
 * Called by the game via the Doomsday public API.
 * Registers a new custom map property which can then be read from a map
 * data lump and passed to the game for processing during load.
 *
 * @param type          DAM object, type identifier e.g. <code>DAM_SIDE</code>
 *                      which this property is to be a attributed to.
 * @param dataType      Data type of this property e.g. <code>DDVT_INT</code>.
 * @param name          Name which is used to associate this property. Used
 *                      when parsing map data, lump format definitions and
 *                      used as a token in text based formats.
 *
 * @return              The index number of this property. The game should
 *                      record this as it will be used to identify the custom
 *                      property when it is passed to it by Doomsday.
 */
uint P_RegisterCustomMapProperty(int type, valuetype_t dataType, char *name)
{
    mapproperty_t *newProp;
    uint        id = type - 1; // DAM_THING == 1
    boolean     exists = false;

    // Are we able to register properties atm?
    if(!canRegisterProps)
        Con_Error("P_RegisterCustomMapProperty: Cannot register properties "
                  "at this time.");

    // Do we have a name?
    if(!name || name[0] == 0)
        Con_Error("P_RegisterCustomMapProperty: Cannot register property "
                  "of type %i to type %s - Custom properties must be named.",
                  dataType, DAM_Str(type));

    // Is the name too long?
    if(strlen(name) > DED_STRINGID_LEN)
        Con_Error("P_RegisterCustomMapProperty: Cannot register property "
                  "\"%s\" to type %s. Property names must be %i characters or less.",
                  name, DAM_Str(type), DED_STRINGID_LEN);

    // Does this type support custom properties?
    if(!DAM_TypeSupportsCustomProperty(type))
        Con_Error("P_RegisterCustomMapProperty: Cannot register property "
                  "\"%s\" - Type %s does not support custom properties.",
                  name, DAM_Str(type));

    // Make sure the name is unique.
    if(DAM_NUM_PROPERTIES > 0)
    {   // Check built-in properties.
        uint        i = 0;
        mapproperty_t *ptr = properties;

        do
        {
            if(ptr->type == type && !stricmp(name, ptr->name))
            {
                exists = true;
            }
            else
            {
                i++;
                ptr++;
            }
        } while(!exists && i < DAM_NUM_PROPERTIES);
    }
    if(!exists && numCustomProps[id] > 0)
    {   // Check custom properties.
        uint        i = 0;
        mapproperty_t *ptr = customProps[id];

        do
        {
            if(!stricmp(name, ptr->name))
            {
                exists = true;
            }
            else
            {
                i++;
                ptr++;
            }
        } while(!exists && i < numCustomProps[id]);
    }

    if(exists)
        Con_Error("P_RegisterCustomMapProperty: Cannot register "
                  "property \"%s\" - A property by this name is "
                  "already attributed to object %s.", name,
                  DAM_Str(type));

    // Is it a known data type?
    switch(dataType)
    {
    case DDVT_BOOL:
    case DDVT_BYTE:
    case DDVT_SHORT:
    case DDVT_INT:
    case DDVT_UINT:
    case DDVT_FIXED:
    case DDVT_ANGLE:
    case DDVT_FLOAT:
    case DDVT_ULONG:
    case DDVT_BLENDMODE:
        break;

    default:
        Con_Error("P_RegisterCustomMapProperty: Cannot register property "
                  "\"%s\" - Invalid type %s.", name, value_Str(dataType));
        break;
    }

    // All is well, register the new property.
    numCustomProps[id]++;
    numTotalCustomProps++;

    customProps[id] =
        Z_Realloc(customProps[id], sizeof(mapproperty_t) * numCustomProps[id],
                  PU_STATIC);
    newProp = &customProps[id][numCustomProps[id] - 1];
    newProp->id = NUM_DAM_PROPERTIES + numTotalCustomProps - 1;
    newProp->type = type;
    newProp->datatype = dataType;
    memset(newProp->name, 0, sizeof(newProp->name));
    strcpy(newProp->name, name);

    VERBOSE2(Con_Message("P_RegisterCustomMapProperty: Added %s->%s (%s)\n",
                        DAM_Str(newProp->type), name, value_Str(newProp->datatype)));

    return newProp->id; // the idx for this property
}


/**
 * Creates an array of all the custom properties for the given DAM object
 * identifier, built-in and custom.
 *
 * NOTE: The returned array must free'd with M_Free().
 *
 * @param type          DAM type to collect the custom props for e.g DAM_SIDE.
 * @param builtIn       If <code>true</code>, include built-in properties.
 * @param custom        If <code>true</code>, include custom properties.
 * @param count         Num props will be written back to this address.
 *
 * @return              Ptr to the array of collected properties.
 */
selectprop_t* DAM_CollectProps(int type, boolean builtIn,
                               boolean custom, uint *count)
{
    uint        i, idx, tid = type - 1;
    uint        totalNum = 0, num = 0;
    selectprop_t *props = NULL;

#if _DEBUG
if(custom && !DAM_TypeSupportsCustomProperty(type))
    Con_Error("collectCustomProps: type does not support custom properties.",
              DAM_Str(type));
#endif

    if(builtIn)
    {
        // Count how many there are.
        num = 0;
        for(i = 0; i < DAM_NUM_PROPERTIES; ++i)
            if(properties[i].type == type)
                num++;

        totalNum += num;
    }
    if(custom)
        totalNum += numCustomProps[tid];

    if(totalNum > 0)
    {
        props = M_Malloc(sizeof(selectprop_t) * totalNum);
        idx = 0;
        if(builtIn && num > 0)
            for(i = 0; i < DAM_NUM_PROPERTIES; ++i)
                if(properties[i].type == type)
                {
                    props[idx].id = properties[i].id;
                    props[idx].valueType = properties[i].datatype;
                    idx++;
                }

        if(custom && numCustomProps[tid] > 0)
            for(i = 0; i < numCustomProps[tid]; ++i)
            {
                props[idx].id = customProps[tid][i].id;
                props[idx].valueType = customProps[tid][i].datatype;
                idx++;
            }
    }

    if(count)
        *count = totalNum;
    return props;
}

selectprop_t* DAM_MergePropLists(selectprop_t *listA, uint numA,
                                    selectprop_t *listB, uint numB,
                                    uint *count)
{
    uint        i, idx, total = numA + numB;
    selectprop_t *newlist;

    newlist = M_Malloc(sizeof(selectprop_t) * total);
    idx = 0;
    for(i = 0; i < numA; ++i)
    {
        newlist[idx].id = listA[i].id;
        newlist[idx].valueType = listA[i].valueType;
        idx++;
    }
    for(i = 0; i < numB; ++i)
    {
        newlist[idx].id = listB[i].id;
        newlist[idx].valueType = listB[i].valueType;
        idx++;
    }

    if(count != NULL)
        *count = total;

    return newlist;
}

/**
 * Initializes a damsetargs struct.
 *
 * @param type  Type of the map data object (e.g., DAM_LINE).
 * @param prop  Property of the map data object.
 */
static void initArgs(damsetargs_t* args, int type, uint prop)
{
    memset(args, 0, sizeof(*args));
    args->type = type;
    args->prop = prop;
}

boolean DAM_ReadMapDataFromLump(gamemap_t *map, maplumpinfo_t *mapLump,
                                uint startIndex, readprop_t *props,
                                uint numProps,
                                int (*callback)(int type, uint index, void* context))
{
    int         type;
    int         result;
    byte       *lumpp;
    damlumpreadargs_t   args;

    // Is this a supported lump type?
    type = DAM_DataTypeForLumpClass(mapLump->lumpClass);
    switch(type)
    {
    case DAM_THING:
    case DAM_VERTEX:
    case DAM_LINE:
    case DAM_SIDE:
    case DAM_SECTOR:
        break;

    default:
        return false; // Read from this lump type is not supported.
    }

     // Select the lump size, number of elements etc...
    args.map = map;
    args.elmsize = Def_GetMapLumpFormat(mapLump->format->formatName)->elmsize;
    args.elements = mapLump->elements;
    args.numProps = numProps;
    args.props = props;

    lumpp = (byte *) W_CacheLumpNum(mapLump->lumpNum, PU_STATIC);

    // Read in that data!
    result =
        ReadAndCallback(type, startIndex, (lumpp + mapLump->startOffset),
                        &args, callback);

    Z_Free(lumpp);
    return result;
}

/**
 * Sets a value. Does some basic type checking so that incompatible types are
 * not assigned. Simple conversions are also done, e.g., float to fixed.
 */
static void SetValue(valuetype_t valueType, void* dst, damsetargs_t* args,
                     uint index)
{
    if(valueType == DDVT_FIXED)
    {
        fixed_t* d = dst;

        switch(args->valueType)
        {
        case DDVT_BYTE:
            *d = (args->byteValues[index] << FRACBITS);
            break;
        case DDVT_INT:
            *d = (args->intValues[index] << FRACBITS);
            break;
        case DDVT_FIXED:
            *d = args->fixedValues[index];
            break;
        case DDVT_FLOAT:
            *d = FLT2FIX(args->floatValues[index]);
            break;
        default:
            Con_Error("SetValue: DDVT_FIXED incompatible with value type %s.\n",
                      value_Str(args->valueType));
        }
    }
    else if(valueType == DDVT_FLOAT)
    {
        float* d = dst;

        switch(args->valueType)
        {
        case DDVT_BYTE:
            *d = args->byteValues[index];
            break;
        case DDVT_SHORT:
            *d = args->shortValues[index];
            break;
        case DDVT_UINT:
            *d = args->uintValues[index];
            break;
        case DDVT_INT:
            *d = args->intValues[index];
            break;
        case DDVT_FIXED:
            *d = FIX2FLT(args->fixedValues[index]);
            break;
        case DDVT_FLOAT:
            *d = args->floatValues[index];
            break;
        default:
            Con_Error("SetValue: DDVT_FLOAT incompatible with value type %s.\n",
                      value_Str(args->valueType));
        }
    }
    else if(valueType == DDVT_BOOL)
    {
        boolean* d = dst;

        switch(args->valueType)
        {
        case DDVT_BOOL:
            *d = args->booleanValues[index];
            break;
        default:
            Con_Error("SetValue: DDVT_BOOL incompatible with value type %s.\n",
                      value_Str(args->valueType));
        }
    }
    else if(valueType == DDVT_BYTE)
    {
        byte* d = dst;

        switch(args->valueType)
        {
        case DDVT_BOOL:
            *d = args->booleanValues[index];
            break;
        case DDVT_BYTE:
            *d = args->byteValues[index];
            break;
        case DDVT_SHORT:
            *d = args->shortValues[index];
            break;
        case DDVT_INT:
            *d = args->intValues[index];
            break;
        case DDVT_FLOAT:
            *d = (byte) args->floatValues[index];
            break;
        default:
            Con_Error("SetValue: DDVT_BYTE incompatible with value type %s.\n",
                      value_Str(args->valueType));
        }
    }
    else if(valueType == DDVT_INT)
    {
        int* d = dst;

        switch(args->valueType)
        {
        case DDVT_BOOL:
            *d = args->booleanValues[index];
            break;
        case DDVT_BYTE:
            *d = args->byteValues[index];
            break;
        case DDVT_INT:
            *d = args->intValues[index];
            break;
        case DDVT_FLOAT:
            *d = args->floatValues[index];
            break;
        case DDVT_FIXED:
            *d = (args->fixedValues[index] >> FRACBITS);
            break;
        default:
            Con_Error("SetValue: DDVT_INT incompatible with value type %s.\n",
                      value_Str(args->valueType));
        }
    }
    else if(valueType == DDVT_UINT)
    {
        uint* d = dst;

        switch(args->valueType)
        {
        case DDVT_BOOL:
            *d = args->booleanValues[index];
            break;
        case DDVT_BYTE:
            *d = args->byteValues[index];
            break;
        case DDVT_INT:
            *d = (unsigned) args->intValues[index];
            break;
        case DDVT_UINT:
            *d = args->uintValues[index];
            break;
        case DDVT_FLOAT:
            *d = (unsigned) args->floatValues[index];
            break;
        case DDVT_FIXED:
            *d = (unsigned) (args->fixedValues[index] >> FRACBITS);
            break;
        default:
            Con_Error("SetValue: DDVT_UINT incompatible with value type %s.\n",
                      value_Str(args->valueType));
        }
    }
    else if(valueType == DDVT_SHORT || valueType == DDVT_FLAT_INDEX)
    {
        short* d = dst;

        switch(args->valueType)
        {
        case DDVT_BOOL:
            *d = args->booleanValues[index];
            break;
        case DDVT_BYTE:
            *d = args->byteValues[index];
            break;
        case DDVT_SHORT:
            *d = args->shortValues[index];
            break;
        case DDVT_INT:
            *d = args->intValues[index];
            break;
        case DDVT_ULONG:
            *d = args->ulongValues[index];
            break;
        case DDVT_FLOAT:
            *d = args->floatValues[index];
            break;
        case DDVT_FIXED:
            *d = (args->fixedValues[index] >> FRACBITS);
            break;
        default:
            Con_Error("SetValue: DDVT_SHORT incompatible with value type %s.\n",
                      value_Str(args->valueType));
        }
    }
    else if(valueType == DDVT_ANGLE)
    {
        angle_t* d = dst;

        switch(args->valueType)
        {
        case DDVT_ANGLE:
            *d = args->angleValues[index];
            break;
        default:
            Con_Error("SetValue: DDVT_ANGLE incompatible with value type %s.\n",
                      value_Str(args->valueType));
        }
    }
    else if(valueType == DDVT_BLENDMODE)
    {
        blendmode_t* d = dst;

        switch(args->valueType)
        {
        case DDVT_INT:
            if(args->intValues[index] > DDNUM_BLENDMODES || args->intValues[index] < 0)
                Con_Error("SetValue: %d is not a valid value for DDVT_BLENDMODE.\n",
                          args->intValues[index]);

            *d = args->intValues[index];
            break;
        default:
            Con_Error("SetValue: DDVT_BLENDMODE incompatible with value type %s.\n",
                      value_Str(args->valueType));
        }
    }
    else if(valueType == DDVT_PTR)
    {
        void** d = dst;

        switch(args->valueType)
        {
        case DDVT_SECT_IDX:
            *(sector_t **) dst = DAM_IndexToPtr(args->map, DAM_SECTOR, (unsigned) args->longValues[index]);
            break;
        case DDVT_VERT_IDX:
            *(vertex_t **) dst = DAM_IndexToPtr(args->map, DAM_VERTEX, (unsigned) args->longValues[index]);
            break;
        case DDVT_LINE_IDX:
            *(line_t **) dst = DAM_IndexToPtr(args->map, DAM_LINE, (unsigned) args->longValues[index]);
            break;
        case DDVT_SIDE_IDX:
            *(side_t **) dst = DAM_IndexToPtr(args->map, DAM_SIDE, (unsigned) args->longValues[index]);
            break;
        case DDVT_PTR:
            *d = args->ptrValues[index];
            break;
        default:
            Con_Error("SetValue: DDVT_PTR incompatible with value type %s.\n",
                      value_Str(args->valueType));
        }
    }
    else
    {
        Con_Error("SetValue: unknown value type %d.\n", valueType);
    }
}

/**
 * Reads a value from the (little endian) source buffer and writes it back
 * to the location specified by damsetargs_t.
 *
 * Does some basic type checking so that incompatible types are not
 * assigned. Simple conversions are also done, e.g., float to fixed.
 */
static void ReadValue(valuetype_t valueType, uint elmIdx, size_t size,
                      const byte *src, damsetargs_t *args, uint index,
                      int flags)
{
    if(valueType == DDVT_BYTE)
    {
        switch(size)
        {
        case 1:
        case 2:
        case 4:
            break;
        default:
            Con_Error("ReadValue: DDVT_BYTE no conversion from %lu bytes.",
                      (unsigned long) size);
        }
        args->byteValues[index] = *src;
    }
    else if(valueType == DDVT_FLOAT)
    {
        float       d = 0;
        switch(size)
        {
        case 2:
            if(flags & DT_UNSIGNED)
            {
                if(flags & DT_FRACBITS)
                    d = FIX2FLT(USHORT(*((int16_t*)(src))) << FRACBITS);
                else
                    d = FIX2FLT(USHORT(*((int16_t*)(src))));
            }
            else
            {
                if(flags & DT_FRACBITS)
                    d = FIX2FLT(SHORT(*((int16_t*)(src))) << FRACBITS);
                else
                    d = FIX2FLT(SHORT(*((int16_t*)(src))));
            }
            break;

        case 4:
            if(flags & DT_UNSIGNED)
            {
                if(flags & DT_FRACBITS)
                    d = FIX2FLT(ULONG(*((int32_t*)(src))) << FRACBITS);
                else
                    d = FIX2FLT(ULONG(*((int32_t*)(src))));
            }
            else
            {
                if(flags & DT_FRACBITS)
                    d = FIX2FLT(LONG(*((int32_t*)(src))) << FRACBITS);
                else
                    d = FIX2FLT(LONG(*((int32_t*)(src))));
            }
            break;

        default:
            Con_Error("ReadValue: DDVT_FLOAT no conversion from %lu bytes.",
                      (unsigned long) size);
        }
        args->floatValues[index] = d;
    }
    else if(valueType == DDVT_SHORT || valueType == DDVT_FLAT_INDEX)
    {
        short       d = 0;
        switch(size)
        {
        case 2:
            if(flags & DT_UNSIGNED)
            {
                if(flags & DT_FRACBITS)
                    d = USHORT(*((int16_t*)(src))) << FRACBITS;
                else
                    d = USHORT(*((int16_t*)(src)));
            }
            else
            {
                if(flags & DT_FRACBITS)
                    d = SHORT(*((int16_t*)(src))) << FRACBITS;
                else
                    d = SHORT(*((int16_t*)(src)));
            }
            break;

        case 8:
            {
            if(flags & DT_TEXTURE)
            {
                d = P_CheckTexture((char*)((int64_t*)(src)), false, valueType,
                                   elmIdx, args->prop);
            }
            else if(flags & DT_FLAT)
            {
                d = P_CheckTexture((char*)((int64_t*)(src)), true, valueType,
                                   elmIdx, args->prop);
            }
            break;
            }
         default:
            Con_Error("ReadValue: DDVT_SHORT no conversion from %lu bytes.",
                      (unsigned long) size);
         }
        args->shortValues[index] = d;
    }
    else if(valueType == DDVT_FIXED)
    {
        fixed_t     d = 0;
        switch(size) // Number of src bytes
        {
        case 2:
            if(flags & DT_UNSIGNED)
            {
                if(flags & DT_FRACBITS)
                    d = USHORT(*((int16_t*)(src))) << FRACBITS;
                else
                    d = USHORT(*((int16_t*)(src)));
            }
            else
            {
                if(flags & DT_FRACBITS)
                    d = SHORT(*((int16_t*)(src))) << FRACBITS;
                else
                    d = SHORT(*((int16_t*)(src)));
            }
            break;

        case 4:
            if(flags & DT_UNSIGNED)
                d = ULONG(*((int32_t*)(src)));
            else
                d = LONG(*((int32_t*)(src)));
            break;

        default:
            Con_Error("ReadValue: DDVT_FIXED no conversion from %lu bytes.",
                      (unsigned long) size);
        }
        args->fixedValues[index] = d;
    }
    else if(valueType == DDVT_ULONG)
    {
        unsigned long   d = 0;

        switch(size) // Number of src bytes
        {
        case 2:
            if(flags & DT_UNSIGNED)
            {
                if(flags & DT_FRACBITS)
                    d = USHORT(*((int16_t*)(src))) << FRACBITS;
                else
                    d = USHORT(*((int16_t*)(src)));
            }
            else
            {
                if(flags & DT_FRACBITS)
                    d = SHORT(*((int16_t*)(src))) << FRACBITS;
                else
                    d = SHORT(*((int16_t*)(src)));
            }
            break;

        case 4:
            if(flags & DT_UNSIGNED)
                d = ULONG(*((int32_t*)(src)));
            else
                d = LONG(*((int32_t*)(src)));
            break;

        default:
            Con_Error("ReadValue: DDVT_ULONG no conversion from %lu bytes.",
                      (unsigned long) size);
        }
        args->ulongValues[index] = d;
    }
    else if(valueType == DDVT_UINT)
    {
        unsigned int    d = 0;

        switch(size) // Number of src bytes
        {
        case 2:
            if(flags & DT_UNSIGNED)
            {
                if(flags & DT_FRACBITS)
                    d = USHORT(*((int16_t*)(src))) << FRACBITS;
                else
                    d = USHORT(*((int16_t*)(src)));
            }
            else
            {
                if(flags & DT_NOINDEX)
                {
                    unsigned short num = SHORT(*((int16_t*)(src)));

                    d = NO_INDEX;

                    if(num != ((unsigned short)-1))
                        d = num;
                }
                else
                {
                    if(flags & DT_FRACBITS)
                        d = SHORT(*((int16_t*)(src))) << FRACBITS;
                    else
                        d = SHORT(*((int16_t*)(src)));
                }
            }
            if((flags & DT_MSBCONVERT) && (d & 0x8000))
            {
                d &= ~0x8000;
                d |= 0x80000000;
            }
            break;

        case 4:
            if(flags & DT_UNSIGNED)
                d = ULONG(*((int32_t*)(src)));
            else
                d = LONG(*((int32_t*)(src)));
            break;

        default:
            Con_Error("ReadValue: DDVT_INT no conversion from %lu bytes.",
                      (unsigned long) size);
        }
        args->uintValues[index] = d;
    }
    else if(valueType == DDVT_VERT_IDX || valueType == DDVT_LINE_IDX ||
            valueType == DDVT_SIDE_IDX || valueType == DDVT_SECT_IDX)
    {
        long d = NO_INDEX;

        switch(size) // Number of src bytes
        {
        case 2:
            if(flags & DT_UNSIGNED)
            {
                d = USHORT(*((int16_t*)(src)));
            }
            else
            {
                if(flags & DT_NOINDEX)
                {
                    unsigned short num = SHORT(*((int16_t*)(src)));

                    if(num != ((unsigned short)-1))
                        d = num;
                }
                else
                {
                    d = SHORT(*((int16_t*)(src)));
                }
            }
            break;

        case 4:
            if(flags & DT_UNSIGNED)
                d = ULONG(*((int32_t*)(src)));
            else
                d = LONG(*((int32_t*)(src)));
            break;

        default:
            Con_Error("ReadValue: %s no conversion from %lu bytes.\n",
                      value_Str(valueType), (unsigned long) size);
        }
        args->longValues[index] = d;
    }
    else if(valueType == DDVT_INT)
    {
        int         d = 0;
        switch(size) // Number of src bytes
        {
        case 2:
            if(flags & DT_UNSIGNED)
            {
                if(flags & DT_FRACBITS)
                    d = USHORT(*((int16_t*)(src))) << FRACBITS;
                else
                    d = USHORT(*((int16_t*)(src)));
            }
            else
            {
                if(flags & DT_NOINDEX)
                {
                    unsigned short num = SHORT(*((int16_t*)(src)));

                    d = NO_INDEX;

                    if(num != ((unsigned short)-1))
                        d = num;
                }
                else
                {
                    if(flags & DT_FRACBITS)
                        d = SHORT(*((int16_t*)(src))) << FRACBITS;
                    else
                        d = SHORT(*((int16_t*)(src)));
                }
            }
            if((flags & DT_MSBCONVERT) && (d & 0x8000))
            {
                d &= ~0x8000;
                d |= 0x80000000;
            }
            break;

        case 4:
            if(flags & DT_UNSIGNED)
                d = ULONG(*((int32_t*)(src)));
            else
                d = LONG(*((int32_t*)(src)));
            break;

        default:
            Con_Error("ReadValue: DDVT_INT no conversion from %lu bytes.",
                      (unsigned long) size);
        }
        args->intValues[index] = d;
    }
    else if(valueType == DDVT_ANGLE)
    {
        angle_t     d = 0;
        switch(size) // Number of src bytes
        {
        case 2:
            if(flags & DT_FRACBITS)
                d = (angle_t) (SHORT(*((int16_t*)(src))) << FRACBITS);
            else
                d = (angle_t) SHORT(*((int16_t*)(src)));
            break;

        default:
            Con_Error("ReadValue: DDVT_ANGLE no conversion from %lu bytes.",
                      (unsigned long) size);
        }
        args->angleValues[index] = d;
    }
    else
    {
        Con_Error("ReadValue: unknown value type %s.\n",
                  value_Str(valueType));
    }
}

static int SetProperty2(void *ptr, void *context)
{
    damsetargs_t *args = (damsetargs_t*) context;

    // These are the exported map data properties that can be
    // assigned to when reading map data.
    switch(args->type)
    {
    case DAM_VERTEX:
        {
        vertex_t* p = ptr;

        switch(args->prop)
        {
        case DAM_X:
            SetValue(DMT_VERTEX_POS, &p->V_pos[VX], args, 0);
            break;

        case DAM_Y:
            SetValue(DMT_VERTEX_POS, &p->V_pos[VY], args, 0);
            break;

        default:
            Con_Error("SetProperty: DAM_VERTEX has no property %s.\n",
                      DAM_Str(args->prop));
        }
        break;
        }
    case DAM_LINE:
        {
        line_t* p = ptr;

        switch(args->prop)
        {
        case DAM_VERTEX1:
            SetValue(DMT_LINE_V, &p->v[0], args, 0);
            break;

        case DAM_VERTEX2:
            SetValue(DMT_LINE_V, &p->v[1], args, 0);
            break;

        case DAM_FLAGS:
            SetValue(DMT_LINE_MAPFLAGS, &p->mapflags, args, 0);
            break;

        case DAM_SIDE0:
            SetValue(DMT_LINE_SIDES, &p->L_frontside, args, 0);
            break;

        case DAM_SIDE1:
            SetValue(DMT_LINE_SIDES, &p->L_backside, args, 0);
            break;

        default:
            Con_Error("SetProperty: DAM_LINE has no property %s.\n",
                      DAM_Str(args->prop));
        }
        break;
        }
    case DAM_SIDE:
        {
        side_t* p = ptr;

        switch(args->prop)
        {
        case DAM_TOP_MATERIAL_OFFSET_X:
            SetValue(DMT_SURFACE_OFFSET, &p->SW_topoffset[VX], args, 0);
            break;

        case DAM_TOP_MATERIAL_OFFSET_Y:
            SetValue(DMT_SURFACE_OFFSET, &p->SW_topoffset[VY], args, 0);
            break;

        case DAM_MIDDLE_MATERIAL_OFFSET_X:
            SetValue(DMT_SURFACE_OFFSET, &p->SW_middleoffset[VX], args, 0);
            break;

        case DAM_MIDDLE_MATERIAL_OFFSET_Y:
            SetValue(DMT_SURFACE_OFFSET, &p->SW_middleoffset[VY], args, 0);
            break;

        case DAM_BOTTOM_MATERIAL_OFFSET_X:
            SetValue(DMT_SURFACE_OFFSET, &p->SW_bottomoffset[VX], args, 0);
            break;

        case DAM_BOTTOM_MATERIAL_OFFSET_Y:
            SetValue(DMT_SURFACE_OFFSET, &p->SW_bottomoffset[VY], args, 0);
            break;

        case DAM_TOP_MATERIAL:
            {
            short           texture;
            SetValue(DMT_MATERIAL, &texture, args, 0);

            p->SW_topmaterial = R_GetMaterial(texture, MAT_TEXTURE);
            }
            break;

        case DAM_MIDDLE_MATERIAL:
            {
            short           texture;
            SetValue(DMT_MATERIAL, &texture, args, 0);

            p->SW_middlematerial = R_GetMaterial(texture, MAT_TEXTURE);
            }
            break;

        case DAM_BOTTOM_MATERIAL:
            {
            short           texture;
            SetValue(DMT_MATERIAL, &texture, args, 0);

            p->SW_bottommaterial = R_GetMaterial(texture, MAT_TEXTURE);
            }
            break;

        case DAM_FRONT_SECTOR:
            SetValue(DMT_SIDE_SECTOR, &p->sector, args, 0);
            break;

        default:
            Con_Error("SetProperty: DAM_SIDE has no property %s.\n",
                      DAM_Str(args->prop));
        }
        break;
        }
    case DAM_SECTOR:
        {
        sector_t* p = ptr;

        switch(args->prop)
        {
        case DAM_FLOOR_HEIGHT:
            SetValue(DMT_PLANE_HEIGHT, &p->SP_floorheight, args, 0);
            break;

        case DAM_CEILING_HEIGHT:
            SetValue(DMT_PLANE_HEIGHT, &p->SP_ceilheight, args, 0);
            break;

        case DAM_FLOOR_MATERIAL:
            {
            short           texture;
            SetValue(DMT_MATERIAL, &texture, args, 0);

            p->SP_floormaterial = R_GetMaterial(texture, MAT_FLAT);
            }
            break;

        case DAM_CEILING_MATERIAL:
            {
            short           texture;
            SetValue(DMT_MATERIAL, &texture, args, 0);

            p->SP_ceilmaterial = R_GetMaterial(texture, MAT_FLAT);
            }
            break;

        case DAM_LIGHT_LEVEL:
            SetValue(DMT_SECTOR_LIGHTLEVEL, &p->lightlevel, args, 0);
            p->lightlevel /= 255.0f;
            break;

        default:
            Con_Error("SetProperty: DAM_SECTOR has no property %s.\n",
                      DAM_Str(args->prop));
        }
        break;
        }
    default:
        Con_Error("SetProperty: Type cannot be assigned to from a map format.\n");
    }

    return true; // Continue iteration
}

int DAM_SetProperty(int type, uint idx, void *context)
{
    uint        index = idx;
    damsetargs_t *args = (damsetargs_t*) context;

    // Handle unknown (game specific) properties.
    if(args->prop >= NUM_DAM_PROPERTIES)
    {
        void        *data = NULL;

        if(!gx.HandleMapDataProperty)
            return true; // Continue iteration.

        switch(args->valueType)
        {
        case DDVT_BYTE:
            data = &args->byteValues[0];
            break;
        case DDVT_SHORT:
            data = &args->shortValues[0];
            break;
        case DDVT_FIXED:
            data = &args->fixedValues[0];
            break;
        case DDVT_INT:
            data = &args->intValues[0];
            break;
        case DDVT_FLOAT:
            data = &args->floatValues[0];
            break;
        default:
            Con_Error("SetProperty: Unsupported data type id %s.\n",
                      value_Str(args->valueType));
        };
        gx.HandleMapDataProperty(index, args->type, args->prop,
                                 args->valueType, data);
        return true; // Continue iteration.
    }
    else
    {
        void       *ptr = (type == DAM_THING? &index :
                           DAM_IndexToPtr(args->map, type, index));
        // \todo Use DMU's SetProperty for this, save code duplication.
        return SetProperty2(ptr, context);
    }
}

static int ReadAndCallback(int dataType, uint startIndex,
                           const byte *buffer, void *context,
                           int (*callback)(int type, uint index, void* ctx))
{
    uint        idx;
    uint        i, k;
    damlumpreadargs_t  *largs = (damlumpreadargs_t*) context;
    const readprop_t *prop;

    damsetargs_t args;
    angle_t     tmpangle;
    boolean     tmpboolean;
    byte        tmpbyte;
    fixed_t     tmpfixed;
    float       tmpfloat;
    short       tmpshort;
    int         tmpint;
    uint        tmpuint;
    long        tmplong;
    unsigned long tmpulong;
    void       *tmpptr;

    for(i = 0, idx = startIndex + i; i < largs->elements; ++i)
    {
        for(prop = &largs->props[k = 0]; k < largs->numProps;
            prop = &largs->props[++k])
        {
            initArgs(&args, dataType, prop->id);
            args.map = largs->map;
            args.valueType = prop->valueType;

            args.angleValues = &tmpangle;
            args.booleanValues = &tmpboolean;
            args.byteValues = &tmpbyte;
            args.fixedValues = &tmpfixed;
            args.floatValues = &tmpfloat;
            args.shortValues = &tmpshort;
            args.intValues = &tmpint;
            args.uintValues = &tmpuint;
            args.longValues = &tmplong;
            args.ulongValues = &tmpulong;
            args.ptrValues = &tmpptr;

            // Read the value(s) from the src buffer and insert into them
            // in a damsetargs_t
            ReadValue(prop->valueType, idx, prop->size,
                      buffer + prop->offset, &args, 0, prop->flags);
            if(!callback(dataType, idx, &args))
                return false;
        }
        buffer += largs->elmsize;
        ++idx;
    }

    return true;
}
