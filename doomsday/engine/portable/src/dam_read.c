/**\file
 *\section License
 * License: GPL
 * Online License Link: http://www.gnu.org/licenses/gpl.html
 *
 *\author Copyright © 2003-2007 Jaakko Keränen <jaakko.keranen@iki.fi>
 *\author Copyright © 2006-2007 Daniel Swanson <danij@dengine.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301  USA
 */

/**
 * dam_read.c: Doomsday Archived Map (DAM).
 *
 * Binary lump reader and custom property management.
 */

// HEADER FILES ------------------------------------------------------------

#include "de_base.h"
#include "de_dam.h"
#include "de_defs.h"
#include "de_misc.h"
#include "de_refresh.h"

#include "p_mapdata.h"

// MACROS ------------------------------------------------------------------

// TYPES -------------------------------------------------------------------

/**
 * Registered by the game during init, these are used by DAM when reading
 * the map lump data as well as the DDay internal data types. The data is
 * read by DDay and any type/size/endian conversion is done before being
 * passed to the game to deal with.
 */
typedef struct {
    uint        id;
    int         type;       // DAM Object type e.g. DAM_SECTOR
    int         datatype;   // e.g. DDVT_INT
    char        name[DED_STRINGID_LEN + 1];
} mapproperty_t;

// EXTERNAL FUNCTION PROTOTYPES --------------------------------------------

// PUBLIC FUNCTION PROTOTYPES ----------------------------------------------

// PRIVATE FUNCTION PROTOTYPES ---------------------------------------------

// EXTERNAL DATA DECLARATIONS ----------------------------------------------

// PUBLIC DATA DEFINITIONS -------------------------------------------------

// PRIVATE DATA DEFINITIONS ------------------------------------------------

// Custom map properties.
static boolean canRegisterProps = false;
static uint numTotalCustomProps;
static mapproperty_t *customProps[DAM_SECTOR];
static uint numCustomProps[DAM_SECTOR];

// \todo this array should be generated by the mapdata.hs script.
#define DAM_NUM_PROPERTIES 22
static mapproperty_t properties[DAM_NUM_PROPERTIES] =
{
// Vertex
    {DAM_X, DAM_VERTEX, DMT_VERTEX_POS, "x"},
    {DAM_Y, DAM_VERTEX, DMT_VERTEX_POS, "y"},
// Line
    // \todo should be DMT_LINE_V but we require special case logic
    {DAM_VERTEX1, DAM_LINE, DDVT_VERT_IDX, "vertex1"},
    {DAM_VERTEX2, DAM_LINE, DDVT_VERT_IDX, "vertex2"},
    {DAM_FLAGS, DAM_LINE, DMT_LINE_MAPFLAGS, "flags"},
    // \todo should be DMT_LINE_SIDES but we require special case logic
    {DAM_SIDE0, DAM_LINE, DDVT_SIDE_IDX, "frontside"},
    // \todo should be DMT_LINE_SIDES but we require special case logic
    {DAM_SIDE1, DAM_LINE, DDVT_SIDE_IDX, "backside"},
// Side
    {DAM_MATERIAL_OFFSET_X, DAM_SIDE, DMT_SURFACE_OFFSET, "textureoffsetx"},
    {DAM_MATERIAL_OFFSET_Y, DAM_SIDE, DMT_SURFACE_OFFSET, "textureoffsety"},
    {DAM_TOP_MATERIAL, DAM_SIDE, DMT_MATERIAL, "toptexture"},
    {DAM_MIDDLE_MATERIAL, DAM_SIDE, DMT_MATERIAL, "middletexture"},
    {DAM_BOTTOM_MATERIAL, DAM_SIDE, DMT_MATERIAL, "bottomtexture"},
    // \todo should be DMT_SIDE_SECTOR but we require special case logic
    {DAM_FRONT_SECTOR, DAM_SIDE, DDVT_SECT_IDX, "frontsector"},
// Sector
    {DAM_FLOOR_HEIGHT, DAM_SECTOR, DMT_PLANE_HEIGHT, "floorheight"},
    {DAM_CEILING_HEIGHT, DAM_SECTOR, DMT_PLANE_HEIGHT, "ceilingheight"},
    {DAM_FLOOR_MATERIAL, DAM_SECTOR, DMT_MATERIAL, "floortexture"},
    {DAM_CEILING_MATERIAL, DAM_SECTOR, DMT_MATERIAL, "ceilingtexture"},
    {DAM_LIGHT_LEVEL, DAM_SECTOR, DDVT_SHORT, "lightlevel"},
};

// CODE --------------------------------------------------------------------

/**
 * Called during engine startup to make ready for the registration of
 * properties to be read from archived map data.
 */
void DAM_InitReader(void)
{
    uint        i;

    canRegisterProps = true;
    for(i = 0; i < DAM_SECTOR; ++i)
    {
        numCustomProps[i] = 0;
        customProps[i] = NULL;
    }
    numTotalCustomProps = 0;
}

void DAM_LockCustomPropertys(void)
{
    // We're now closed for business.
    canRegisterProps = false;
}

/**
 * Does the specified DAM object type support custom properites?
 *
 * @param type      DAM object, type identifier e.g. @c DAM_SIDE to check
 *                  for custom property support.
 * @return          @c true, if the map object supports custom properties.
 */
boolean DAM_TypeSupportsCustomProperty(int type)
{
    switch(type)
    {
    case DAM_THING:
    case DAM_VERTEX:
    case DAM_LINE:
    case DAM_SIDE:
    case DAM_SECTOR:
        return true;

    default:
        break;
    }

    return false;
}

uint DAM_IDForProperty(int type, char *name)
{
    uint        i, propID = 0;
    boolean     found = false;

    // Check built-in properties first.
    if(DAM_NUM_PROPERTIES > 0)
    {
        mapproperty_t *ptr = properties;
        i = 0;
        do
        {
            if(ptr->type == type && !stricmp(ptr->name, name))
            {
                propID = ptr->id;
                found = true;
            }
            else
            {
                i++;
                ptr++;
            }
        } while(!found && i < DAM_NUM_PROPERTIES);
    }

    // Check custom properties.
    if(!found && DAM_TypeSupportsCustomProperty(type))
    {
        uint        id = type - 1;
        if(numCustomProps[id] > 0)
        {
            mapproperty_t *ptr = customProps[id];
            i = 0;
            do
            {
                if(!stricmp(name, ptr->name))
                {
                    propID = ptr->id;
                    found = true;
                }
                else
                {
                    i++;
                    ptr++;
                }
            } while(!found && i < numCustomProps[id]);
        }
    }

    return propID;
}

/**
 * Called by the game via the Doomsday public API.
 * Registers a new custom map property which can then be read from a map
 * data lump and passed to the game for processing during load.
 *
 * @param type          DAM object, type identifier e.g. @c DAM_SIDE
 *                      which this property is to be a attributed to.
 * @param dataType      Data type of this property e.g. @c DDVT_INT
 * @param name          Name which is used to associate this property. Used
 *                      when parsing map data, lump format definitions and
 *                      used as a token in text based formats.
 *
 * @return              The index number of this property. The game should
 *                      record this as it will be used to identify the custom
 *                      property when it is passed to it by Doomsday.
 */
uint P_RegisterCustomMapProperty(int type, valuetype_t dataType, char *name)
{
    mapproperty_t *newProp;
    uint        id = type - 1; // DAM_THING == 1
    boolean     exists = false;

    // Are we able to register properties atm?
    if(!canRegisterProps)
        Con_Error("P_RegisterCustomMapProperty: Cannot register properties "
                  "at this time.");

    // Do we have a name?
    if(!name || name[0] == 0)
        Con_Error("P_RegisterCustomMapProperty: Cannot register property "
                  "of type %i to type %s - Custom properties must be named.",
                  dataType, DAM_Str(type));

    // Is the name too long?
    if(strlen(name) > DED_STRINGID_LEN)
        Con_Error("P_RegisterCustomMapProperty: Cannot register property "
                  "\"%s\" to type %s. Property names must be %i characters or less.",
                  name, DAM_Str(type), DED_STRINGID_LEN);

    // Does this type support custom properties?
    if(!DAM_TypeSupportsCustomProperty(type))
        Con_Error("P_RegisterCustomMapProperty: Cannot register property "
                  "\"%s\" - Type %s does not support custom properties.",
                  name, DAM_Str(type));

    // Make sure the name is unique.
    if(DAM_NUM_PROPERTIES > 0)
    {   // Check built-in properties.
        uint        i = 0;
        mapproperty_t *ptr = properties;

        do
        {
            if(ptr->type == type && !stricmp(name, ptr->name))
            {
                exists = true;
            }
            else
            {
                i++;
                ptr++;
            }
        } while(!exists && i < DAM_NUM_PROPERTIES);
    }
    if(!exists && numCustomProps[id] > 0)
    {   // Check custom properties.
        uint        i = 0;
        mapproperty_t *ptr = customProps[id];

        do
        {
            if(!stricmp(name, ptr->name))
            {
                exists = true;
            }
            else
            {
                i++;
                ptr++;
            }
        } while(!exists && i < numCustomProps[id]);
    }

    if(exists)
        Con_Error("P_RegisterCustomMapProperty: Cannot register "
                  "property \"%s\" - A property by this name is "
                  "already attributed to object %s.", name,
                  DAM_Str(type));

    // Is it a known data type?
    switch(dataType)
    {
    case DDVT_BOOL:
    case DDVT_BYTE:
    case DDVT_SHORT:
    case DDVT_INT:
    case DDVT_UINT:
    case DDVT_FIXED:
    case DDVT_ANGLE:
    case DDVT_FLOAT:
    case DDVT_ULONG:
    case DDVT_BLENDMODE:
        break;

    default:
        Con_Error("P_RegisterCustomMapProperty: Cannot register property "
                  "\"%s\" - Invalid type %s.", name, value_Str(dataType));
        break;
    }

    // All is well, register the new property.
    numCustomProps[id]++;
    numTotalCustomProps++;

    customProps[id] =
        Z_Realloc(customProps[id], sizeof(mapproperty_t) * numCustomProps[id],
                  PU_STATIC);
    newProp = &customProps[id][numCustomProps[id] - 1];
    newProp->id = NUM_DAM_PROPERTIES + numTotalCustomProps - 1;
    newProp->type = type;
    newProp->datatype = dataType;
    memset(newProp->name, 0, sizeof(newProp->name));
    strcpy(newProp->name, name);

    VERBOSE2(Con_Message("P_RegisterCustomMapProperty: Added %s->%s (%s)\n",
                        DAM_Str(newProp->type), name, value_Str(newProp->datatype)));

    return newProp->id; // the idx for this property
}

/**
 * Creates an array of all the custom properties for the given DAM object
 * identifier, built-in and custom.
 *
 * NOTE: The returned array must free'd with M_Free().
 *
 * @param type          DAM type to collect the custom props for e.g DAM_SIDE.
 * @param builtIn       @c true, include built-in properties.
 * @param custom        @c true, include custom properties.
 * @param count         Num props will be written back to this address.
 *
 * @return              Ptr to the array of collected properties.
 */
selectprop_t* DAM_CollectProps(int type, boolean builtIn,
                               boolean custom, uint *count)
{
    uint        i, idx, tid = type - 1;
    uint        totalNum = 0, num = 0;
    selectprop_t *props = NULL;

#if _DEBUG
if(custom && !DAM_TypeSupportsCustomProperty(type))
    Con_Error("collectCustomProps: type does not support custom properties.",
              DAM_Str(type));
#endif

    if(builtIn)
    {
        // Count how many there are.
        num = 0;
        for(i = 0; i < DAM_NUM_PROPERTIES; ++i)
            if(properties[i].type == type)
                num++;

        totalNum += num;
    }
    if(custom)
        totalNum += numCustomProps[tid];

    if(totalNum > 0)
    {
        props = M_Malloc(sizeof(selectprop_t) * totalNum);
        idx = 0;
        if(builtIn && num > 0)
            for(i = 0; i < DAM_NUM_PROPERTIES; ++i)
                if(properties[i].type == type)
                {
                    props[idx].id = properties[i].id;
                    props[idx].valueType = properties[i].datatype;
                    idx++;
                }

        if(custom && numCustomProps[tid] > 0)
            for(i = 0; i < numCustomProps[tid]; ++i)
            {
                props[idx].id = customProps[tid][i].id;
                props[idx].valueType = customProps[tid][i].datatype;
                idx++;
            }
    }

    if(count)
        *count = totalNum;
    return props;
}

selectprop_t* DAM_MergePropLists(selectprop_t *listA, uint numA,
                                    selectprop_t *listB, uint numB,
                                    uint *count)
{
    uint        i, idx, total = numA + numB;
    selectprop_t *newlist;

    newlist = M_Malloc(sizeof(selectprop_t) * total);
    idx = 0;
    for(i = 0; i < numA; ++i)
    {
        newlist[idx].id = listA[i].id;
        newlist[idx].valueType = listA[i].valueType;
        idx++;
    }
    for(i = 0; i < numB; ++i)
    {
        newlist[idx].id = listB[i].id;
        newlist[idx].valueType = listB[i].valueType;
        idx++;
    }

    if(count != NULL)
        *count = total;

    return newlist;
}
