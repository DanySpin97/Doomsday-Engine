group model {
    # Shader for skeletal animation and generic per-pixel lighting:
    # diffuse color, normal map, emission map, specular intensity.
    shader skeletal.normal_emission {
        vertex = "
            uniform highp mat4 uMvpMatrix;
            uniform highp mat4 uBoneMatrices[64];
            uniform highp vec3 uLightDirs[4];
            uniform highp vec3 uEyeDir;

            attribute highp vec4 aVertex;
            attribute highp vec3 aNormal;
            attribute highp vec3 aTangent;
            attribute highp vec3 aBitangent;
            attribute highp vec2 aUV;
            attribute highp vec4 aBounds;   // diffuse map
            attribute highp vec4 aBounds2;  // normal map
            attribute highp vec4 aBoneIDs;
            attribute highp vec4 aBoneWeights;

            varying highp vec2 vUV;
            varying highp vec2 vNormalUV;
            varying highp vec3 vLightDirs[4]; // tangent space
            varying highp vec3 vEyeDir;       // tangent space

            highp vec3 transformVector(highp vec3 dir, highp mat4 matrix) {
                return (matrix * vec4(dir, 0.0)).xyz;
            }

            void main(void) {
                // Bone transformation.
                highp mat4 bone =
                    uBoneMatrices[int(aBoneIDs.x + 0.5)] * aBoneWeights.x +
                    uBoneMatrices[int(aBoneIDs.y + 0.5)] * aBoneWeights.y +
                    uBoneMatrices[int(aBoneIDs.z + 0.5)] * aBoneWeights.z +
                    uBoneMatrices[int(aBoneIDs.w + 0.5)] * aBoneWeights.w;
                    
                // Vertex position.
                highp vec4 modelPos = bone * aVertex;
                gl_Position = uMvpMatrix * modelPos;
                
                // Tangent space.
                highp vec3 normal       = transformVector(aNormal, bone);
                highp vec3 tangent      = transformVector(aTangent, bone);
                highp vec3 bitangent    = transformVector(aBitangent, bone);
                highp mat3 tangentSpace = mat3(tangent, bitangent, normal);
                
                // Light direction in tangent space.
                vLightDirs[0] = uLightDirs[0] * tangentSpace;
                vLightDirs[1] = uLightDirs[1] * tangentSpace;
                vLightDirs[2] = uLightDirs[2] * tangentSpace;
                vLightDirs[3] = uLightDirs[3] * tangentSpace;
                
                // Eye direction in tangent space.
                vEyeDir = uEyeDir * tangentSpace;
                
                vUV       = aBounds.xy  + aUV * aBounds.zw;
                vNormalUV = aBounds2.xy + aUV * aBounds2.zw;
            }"
        fragment = "
            uniform sampler2D uTex;
            uniform highp vec4 uLightIntensities[4];
            
            varying highp vec2 vUV;
            varying highp vec2 vNormalUV;
            varying highp vec3 vLightDirs[4]; // tangent space
            varying highp vec3 vEyeDir;       // tangent space
            
            highp vec3 normalVector() {
                return (texture2D(uTex, vNormalUV).xyz * 2.0) - 1.0;
            }

            highp vec4 diffuseLight(int index, highp vec3 normal) {
                highp float d = dot(normal, normalize(vLightDirs[index]));
                return max(d * uLightIntensities[index],
                           vec4(0.0, 0.0, 0.0, 0.0));
            }
            
            void main(void) {        
                highp vec3 normal = normalVector();
                        
                gl_FragColor = //texture2D(uTex, vUV);
                    diffuseLight(0, normal) + 
                    diffuseLight(1, normal) + 
                    diffuseLight(2, normal) + 
                    diffuseLight(3, normal);
                gl_FragColor.a = 1.0;
                
                gl_FragColor.rgb = vec3(normalize(vEyeDir).z);
            }"
    }
}
