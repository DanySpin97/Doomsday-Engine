# Doomsday's Core Set of Shaders
#
# In each "shader" block, there can be:
# - path:          path to both the .vsh and .fsh files (omit extension:
#                  "shaders/test" => shaders/test.vsh, shaders/test.fsh)
# - path.vertex:   path to the vertex shader file
# - path.fragment: path to the fragment shader file
# - vertex:        source of the vertex shader
# - fragment:      source of the fragment shader

group generic {
    # Simple shader with untextured vertices. There is an additional constant
    # color applied to all vertices. Uses a combined model-view-projection
    # matrix.
    shader color_ucolor {
        vertex = "
            uniform highp mat4 uMvpMatrix;
            uniform highp vec4 uColor;
            attribute highp vec4 aVertex;
            attribute highp vec4 aColor;
            varying highp vec4 vColor;
            
            void main(void) {
                gl_Position = uMvpMatrix * aVertex;
                vColor = uColor * aColor;
            }"
        fragment = "
            varying highp vec4 vColor;
            
            void main(void) {
                gl_FragColor = vColor;
            }"
    }
    
    shader texture {
        vertex = "
            uniform highp mat4 uMvpMatrix;
            attribute highp vec4 aVertex;
            attribute highp vec2 aUV;
            varying highp vec2 vUV;
        
            void main(void) {
                gl_Position = uMvpMatrix * aVertex;
                vUV = aUV;
            }"
        fragment = "
            uniform sampler2D uTex;
            varying highp vec2 vUV;

            void main(void) {
                gl_FragColor = texture2D(uTex, vUV);
            }"        
    }
    
    group textured {    
        # Simple shader with one texture plus a color per vertex. Uses a
        # combined model-view-projection matrix.
        shader color {
            vertex = "
                uniform highp mat4 uMvpMatrix;
                attribute highp vec4 aVertex;
                attribute highp vec2 aUV;
                attribute highp vec4 aColor;
                varying highp vec2 vUV;
                varying highp vec4 vColor;
            
                void main(void) {
                    gl_Position = uMvpMatrix * aVertex;
                    vUV = aUV;
                    vColor = aColor;
                }"
            fragment = "
                uniform sampler2D uTex;
                varying highp vec2 vUV;
                varying highp vec4 vColor;

                void main(void) {
                    gl_FragColor = vColor * texture2D(uTex, vUV);
                }"
        }
    
        # Simple shader with one texture plus a color per vertex. There is
        # an additional constant color applied to all vertices. Uses a
        # combined model-view-projection matrix.
        shader color_ucolor {
            vertex = "
                uniform highp mat4 uMvpMatrix;
                uniform highp vec4 uColor;
                attribute highp vec4 aVertex;
                attribute highp vec2 aUV;
                attribute highp vec4 aColor;
                varying highp vec2 vUV;
                varying highp vec4 vColor;
            
                void main(void) {
                    gl_Position = uMvpMatrix * aVertex;
                    vUV = aUV;
                    vColor = aColor * uColor;
                }"
            fragment = "
                uniform sampler2D uTex;
                varying highp vec2 vUV;
                varying highp vec4 vColor;

                void main(void) {
                    gl_FragColor = vColor * texture2D(uTex, vUV);
                }"
        }
    }
}

group fx {
    # Blurring is done in two passes: horizontal and vertical. This is more
    # efficient than doing the equivalent amount of blurring in a single pass.
    group blur {
        shader horizontal {
            path.vertex   = "shaders/blur.vsh"
            path.fragment = "shaders/blur-horizontal.fsh"
        }
        shader vertical {
            path.vertex   = "shaders/blur.vsh"
            path.fragment = "shaders/blur-vertical.fsh"
        }
    }

    # Bloom is a specialized additive blur that only applies to bright pixels 
    # (given a configurable threshold for brightness).
    group bloom {
        shader horizontal {
            path.vertex   = "shaders/bloom.vsh"
            path.fragment = "shaders/bloom-horizontal.fsh"
        }
        shader vertical {
            path.vertex   = "shaders/bloom.vsh"
            path.fragment = "shaders/bloom-vertical.fsh"
        }
    }

    shader lensflares {
        path.vertex   = "shaders/lensflares.vsh"
        path.fragment = "shaders/lensflares.fsh"
    }

    # Post-processing shaders need to have uFadeInOut (0..1) for
    # fading the effect in/out.
    group post {
        shader monochrome {
            vertex = "
                uniform highp mat4 uMvpMatrix;
                attribute highp vec4 aVertex;
                attribute highp vec2 aUV;
                varying highp vec2 vUV;
        
                void main(void) {
                    gl_Position = uMvpMatrix * aVertex;
                    vUV = aUV;
                }"
            fragment = "
                uniform sampler2D uTex;
                uniform highp float uFadeInOut;                
                varying highp vec2 vUV;

                void main(void) {
                    highp vec4 original = texture2D(uTex, vUV);
                    highp float intens = 
                        (0.2125 * original.r) + 
                        (0.7154 * original.g) + 
                        (0.0721 * original.b);
                    gl_FragColor = vec4(vec3(intens), 1.0);
                    if(uFadeInOut < 1.0) {
                        gl_FragColor = mix(original, gl_FragColor, uFadeInOut);
                    }
                }"        
        }
        
        shader monochrome.inverted {
            vertex = "
                uniform highp mat4 uMvpMatrix;
                attribute highp vec4 aVertex;
                attribute highp vec2 aUV;
                varying highp vec2 vUV;
        
                void main(void) {
                    gl_Position = uMvpMatrix * aVertex;
                    vUV = aUV;
                }"
            fragment = "
                uniform sampler2D uTex;
                uniform highp float uFadeInOut;                
                varying highp vec2 vUV;

                void main(void) {
                    highp vec4 original = texture2D(uTex, vUV);
                    highp float intens = 
                        (0.2125 * original.r) + 
                        (0.7154 * original.g) + 
                        (0.0721 * original.b);
                        
                    gl_FragColor = vec4(vec3(1.0 - intens), 1.0);
                    if(uFadeInOut < 1.0) {
                        gl_FragColor = mix(original, gl_FragColor, uFadeInOut);
                    }
                }"        
        }        
    }
}

group vr {
    group oculusrift {
        shader barrel {
            vertex = "
                #version 120
                attribute highp vec4 aVertex;
                attribute highp vec2 aUV;
                varying highp vec2 vTexCoord;
                void main() {
                    gl_Position = aVertex;
                    vTexCoord = aUV;
                }"
            path.fragment = "shaders/oculusrift-barrel.fsh"
        }
    }
}

group debug {
    group textured {    
        # Visualize alpha information.
        shader alpha {
            vertex = "
                uniform highp mat4 uMvpMatrix;
                attribute highp vec4 aVertex;
                attribute highp vec2 aUV;
                attribute highp vec4 aColor;
                varying highp vec2 vUV;
                varying highp vec4 vColor;
            
                void main(void) {
                    gl_Position = uMvpMatrix * aVertex;
                    vUV = aUV;
                    vColor = aColor;
                }"
            fragment = "
                uniform sampler2D uTex;
                varying highp vec2 vUV;
                varying highp vec4 vColor;

                void main(void) {
                    highp vec4 col = vColor * texture2D(uTex, vUV);
                    gl_FragColor = vec4(col.a, col.a, col.a, 1.0);
                }"
        }
    }
}
